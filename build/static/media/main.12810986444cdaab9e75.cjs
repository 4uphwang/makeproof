"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var binFileUtils=require("@iden3/binfileutils"),ffjavascript=require("ffjavascript"),Blake2b=require("blake2b-wasm"),readline=require("readline"),crypto=require("crypto"),fastFile=require("fastfile"),circom_runtime=require("circom_runtime"),r1csfile=require("r1csfile"),ejs=require("ejs"),jsSha3=require("js-sha3");function _interopDefaultLegacy(e){return e&&"object"===typeof e&&"default"in e?e:{default:e}}function _interopNamespace(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(a){if("default"!==a){var i=Object.getOwnPropertyDescriptor(e,a);Object.defineProperty(t,a,i.get?i:{enumerable:!0,get:function(){return e[a]}})}})),t.default=e,Object.freeze(t)}var binFileUtils__namespace=_interopNamespace(binFileUtils),Blake2b__default=_interopDefaultLegacy(Blake2b),readline__default=_interopDefaultLegacy(readline),crypto__default=_interopDefaultLegacy(crypto),fastFile__namespace=_interopNamespace(fastFile),ejs__default=_interopDefaultLegacy(ejs),jsSha3__default=_interopDefaultLegacy(jsSha3);ffjavascript.Scalar.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),ffjavascript.Scalar.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");const bls12381q=ffjavascript.Scalar.e("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab",16),bn128q=ffjavascript.Scalar.e("21888242871839275222246405745257275088696311157297823662689037894645226208583");async function getCurveFromQ(e){let t;if(ffjavascript.Scalar.eq(e,bn128q))t=await ffjavascript.buildBn128();else{if(!ffjavascript.Scalar.eq(e,bls12381q))throw new Error(`Curve not supported: ${ffjavascript.Scalar.toString(e)}`);t=await ffjavascript.buildBls12381()}return t}async function getCurveFromName(e){let t;const a=e.toUpperCase().match(/[A-Za-z0-9]+/g).join("");if(["BN128","BN254","ALTBN128"].indexOf(a)>=0)t=await ffjavascript.buildBn128();else{if(!(["BLS12381"].indexOf(a)>=0))throw new Error(`Curve not supported: ${e}`);t=await ffjavascript.buildBls12381()}return t}function log2(e){return(0!==(4294901760&e)?(e&=4294901760,16):0)|(0!==(4278255360&e)?(e&=4278255360,8):0)|(0!==(4042322160&e)?(e&=4042322160,4):0)|(0!==(3435973836&e)?(e&=3435973836,2):0)|0!==(2863311530&e)}function formatHash(e,t){const a=new DataView(e.buffer,e.byteOffset,e.byteLength);let i="";for(let n=0;n<4;n++){n>0&&(i+="\n"),i+="\t\t";for(let e=0;e<4;e++)e>0&&(i+=" "),i+=a.getUint32(16*n+4*e).toString(16).padStart(8,"0")}return t&&(i=t+"\n"+i),i}function hashIsEqual(e,t){if(e.byteLength!=t.byteLength)return!1;for(var a=new Int8Array(e),i=new Int8Array(t),n=0;n!=e.byteLength;n++)if(a[n]!=i[n])return!1;return!0}function cloneHasher(e){const t=e.getPartialHash(),a=Blake2b__default.default(64);return a.setPartialHash(t),a}async function sameRatio$2(e,t,a,i,n){if(e.G1.isZero(t))return!1;if(e.G1.isZero(a))return!1;if(e.G2.isZero(i))return!1;if(e.G2.isZero(n))return!1;return await e.pairingEq(t,n,e.G1.neg(a),i)}function askEntropy(){if(process.browser)return window.prompt("Enter a random text. (Entropy): ","");{const e=readline__default.default.createInterface({input:process.stdin,output:process.stdout});return new Promise((t=>{e.question("Enter a random text. (Entropy): ",(e=>t(e)))}))}}async function getRandomRng(e){for(;!e;)e=await askEntropy();const t=Blake2b__default.default(64);t.update(crypto__default.default.randomBytes(64));const a=new TextEncoder;t.update(a.encode(e));const i=Buffer.from(t.digest()),n=[];for(let r=0;r<8;r++)n[r]=i.readUInt32BE(4*r);return new ffjavascript.ChaCha(n)}function rngFromBeaconParams(e,t){let a,i;t<32?(a=1<<t>>>0,i=1):(a=4294967296,i=1<<t-32>>>0);let n=e;for(let s=0;s<i;s++)for(let e=0;e<a;e++)n=crypto__default.default.createHash("sha256").update(n).digest();const r=new DataView(n.buffer,n.byteOffset,n.byteLength),o=[];for(let s=0;s<8;s++)o[s]=r.getUint32(4*s,!1);return new ffjavascript.ChaCha(o)}function hex2ByteArray(e){return e instanceof Uint8Array?e:("0x"==e.slice(0,2)&&(e=e.slice(2)),new Uint8Array(e.match(/[\da-f]{2}/gi).map((function(e){return parseInt(e,16)}))))}function byteArray2hex(e){return Array.prototype.map.call(e,(function(e){return("0"+(255&e).toString(16)).slice(-2)})).join("")}function stringifyBigIntsWithField(e,t){if(t instanceof Uint8Array)return e.toString(t);if(Array.isArray(t))return t.map(stringifyBigIntsWithField.bind(null,e));if("object"==typeof t){const a={};return Object.keys(t).forEach((i=>{a[i]=stringifyBigIntsWithField(e,t[i])})),a}return"bigint"==typeof t||void 0!==t.eq?t.toString(10):t}async function writeHeader(e,t){await binFileUtils__namespace.startWriteSection(e,1),await e.writeULE32(1),await binFileUtils__namespace.endWriteSection(e);const a=await getCurveFromQ(t.q);await binFileUtils__namespace.startWriteSection(e,2);const i=a.q,n=8*(Math.floor((ffjavascript.Scalar.bitLength(i)-1)/64)+1),r=a.r,o=8*(Math.floor((ffjavascript.Scalar.bitLength(r)-1)/64)+1);await e.writeULE32(n),await binFileUtils__namespace.writeBigInt(e,i,n),await e.writeULE32(o),await binFileUtils__namespace.writeBigInt(e,r,o),await e.writeULE32(t.nVars),await e.writeULE32(t.nPublic),await e.writeULE32(t.domainSize),await writeG1(e,a,t.vk_alpha_1),await writeG1(e,a,t.vk_beta_1),await writeG2(e,a,t.vk_beta_2),await writeG2(e,a,t.vk_gamma_2),await writeG1(e,a,t.vk_delta_1),await writeG2(e,a,t.vk_delta_2),await binFileUtils__namespace.endWriteSection(e)}async function writeG1(e,t,a){const i=new Uint8Array(2*t.G1.F.n8);t.G1.toRprLEM(i,0,a),await e.write(i)}async function writeG2(e,t,a){const i=new Uint8Array(2*t.G2.F.n8);t.G2.toRprLEM(i,0,a),await e.write(i)}async function readG1(e,t,a){const i=await e.read(2*t.G1.F.n8),n=t.G1.fromRprLEM(i,0);return a?t.G1.toObject(n):n}async function readG2(e,t,a){const i=await e.read(2*t.G2.F.n8),n=t.G2.fromRprLEM(i,0);return a?t.G2.toObject(n):n}async function readHeader$1(e,t,a){await binFileUtils__namespace.startReadUniqueSection(e,t,1);const i=await e.readULE32();if(await binFileUtils__namespace.endReadSection(e),1==i)return await readHeaderGroth16(e,t,a);if(2==i)return await readHeaderPlonk(e,t,a);throw new Error("Protocol not supported: ")}async function readHeaderGroth16(e,t,a){const i={protocol:"groth16"};await binFileUtils__namespace.startReadUniqueSection(e,t,2);const n=await e.readULE32();i.n8q=n,i.q=await binFileUtils__namespace.readBigInt(e,n);const r=await e.readULE32();return i.n8r=r,i.r=await binFileUtils__namespace.readBigInt(e,r),i.curve=await getCurveFromQ(i.q),i.nVars=await e.readULE32(),i.nPublic=await e.readULE32(),i.domainSize=await e.readULE32(),i.power=log2(i.domainSize),i.vk_alpha_1=await readG1(e,i.curve,a),i.vk_beta_1=await readG1(e,i.curve,a),i.vk_beta_2=await readG2(e,i.curve,a),i.vk_gamma_2=await readG2(e,i.curve,a),i.vk_delta_1=await readG1(e,i.curve,a),i.vk_delta_2=await readG2(e,i.curve,a),await binFileUtils__namespace.endReadSection(e),i}async function readHeaderPlonk(e,t,a){const i={protocol:"plonk"};await binFileUtils__namespace.startReadUniqueSection(e,t,2);const n=await e.readULE32();i.n8q=n,i.q=await binFileUtils__namespace.readBigInt(e,n);const r=await e.readULE32();return i.n8r=r,i.r=await binFileUtils__namespace.readBigInt(e,r),i.curve=await getCurveFromQ(i.q),i.nVars=await e.readULE32(),i.nPublic=await e.readULE32(),i.domainSize=await e.readULE32(),i.power=log2(i.domainSize),i.nAdditions=await e.readULE32(),i.nConstrains=await e.readULE32(),i.k1=await e.read(r),i.k2=await e.read(r),i.Qm=await readG1(e,i.curve,a),i.Ql=await readG1(e,i.curve,a),i.Qr=await readG1(e,i.curve,a),i.Qo=await readG1(e,i.curve,a),i.Qc=await readG1(e,i.curve,a),i.S1=await readG1(e,i.curve,a),i.S2=await readG1(e,i.curve,a),i.S3=await readG1(e,i.curve,a),i.X_2=await readG2(e,i.curve,a),await binFileUtils__namespace.endReadSection(e),i}async function readZKey(e,t){const{fd:a,sections:i}=await binFileUtils__namespace.readBinFile(e,"zkey",1),n=await readHeader$1(a,i,t),r=new ffjavascript.F1Field(n.r),o=ffjavascript.Scalar.mod(ffjavascript.Scalar.shl(1,8*n.n8r),n.r),s=r.inv(o),l=r.mul(s,s);let c=await getCurveFromQ(n.q);await binFileUtils__namespace.startReadUniqueSection(a,i,3),n.IC=[];for(let d=0;d<=n.nPublic;d++){const e=await readG1(a,c,t);n.IC.push(e)}await binFileUtils__namespace.endReadSection(a),await binFileUtils__namespace.startReadUniqueSection(a,i,4);const u=await a.readULE32();n.ccoefs=[];for(let d=0;d<u;d++){const e=await a.readULE32(),t=await a.readULE32(),i=await a.readULE32(),r=await f();n.ccoefs.push({matrix:e,constraint:t,signal:i,value:r})}await binFileUtils__namespace.endReadSection(a),await binFileUtils__namespace.startReadUniqueSection(a,i,5),n.A=[];for(let d=0;d<n.nVars;d++){const e=await readG1(a,c,t);n.A[d]=e}await binFileUtils__namespace.endReadSection(a),await binFileUtils__namespace.startReadUniqueSection(a,i,6),n.B1=[];for(let d=0;d<n.nVars;d++){const e=await readG1(a,c,t);n.B1[d]=e}await binFileUtils__namespace.endReadSection(a),await binFileUtils__namespace.startReadUniqueSection(a,i,7),n.B2=[];for(let d=0;d<n.nVars;d++){const e=await readG2(a,c,t);n.B2[d]=e}await binFileUtils__namespace.endReadSection(a),await binFileUtils__namespace.startReadUniqueSection(a,i,8),n.C=[];for(let d=n.nPublic+1;d<n.nVars;d++){const e=await readG1(a,c,t);n.C[d]=e}await binFileUtils__namespace.endReadSection(a),await binFileUtils__namespace.startReadUniqueSection(a,i,9),n.hExps=[];for(let d=0;d<n.domainSize;d++){const e=await readG1(a,c,t);n.hExps.push(e)}return await binFileUtils__namespace.endReadSection(a),await a.close(),n;async function f(){const e=await binFileUtils__namespace.readBigInt(a,n.n8r);return r.mul(e,l)}}async function readContribution$1(e,t,a){const i={delta:{}};i.deltaAfter=await readG1(e,t,a),i.delta.g1_s=await readG1(e,t,a),i.delta.g1_sx=await readG1(e,t,a),i.delta.g2_spx=await readG2(e,t,a),i.transcript=await e.read(64),i.type=await e.readULE32();const n=await e.readULE32(),r=e.pos;let o=0;for(;e.pos-r<n;){const t=await e.read(1);if(t[0]<=o)throw new Error("Parameters in the contribution must be sorted");if(o=t[0],1==t[0]){const t=await e.read(1),a=await e.read(t[0]);i.name=(new TextDecoder).decode(a)}else if(2==t[0]){const t=await e.read(1);i.numIterationsExp=t[0]}else{if(3!=t[0])throw new Error("Parameter not recognized");{const t=await e.read(1);i.beaconHash=await e.read(t[0])}}}if(e.pos!=r+n)throw new Error("Parametes do not match");return i}async function readMPCParams(e,t,a){await binFileUtils__namespace.startReadUniqueSection(e,a,10);const i={contributions:[]};i.csHash=await e.read(64);const n=await e.readULE32();for(let r=0;r<n;r++){const a=await readContribution$1(e,t);i.contributions.push(a)}return await binFileUtils__namespace.endReadSection(e),i}async function writeContribution$1(e,t,a){await writeG1(e,t,a.deltaAfter),await writeG1(e,t,a.delta.g1_s),await writeG1(e,t,a.delta.g1_sx),await writeG2(e,t,a.delta.g2_spx),await e.write(a.transcript),await e.writeULE32(a.type||0);const i=[];if(a.name){i.push(1);const e=new TextEncoder("utf-8").encode(a.name.substring(0,64));i.push(e.byteLength);for(let t=0;t<e.byteLength;t++)i.push(e[t])}if(1==a.type){i.push(2),i.push(a.numIterationsExp),i.push(3),i.push(a.beaconHash.byteLength);for(let e=0;e<a.beaconHash.byteLength;e++)i.push(a.beaconHash[e])}if(i.length>0){const t=new Uint8Array(i);await e.writeULE32(t.byteLength),await e.write(t)}else await e.writeULE32(0)}async function writeMPCParams(e,t,a){await binFileUtils__namespace.startWriteSection(e,10),await e.write(a.csHash),await e.writeULE32(a.contributions.length);for(let i=0;i<a.contributions.length;i++)await writeContribution$1(e,t,a.contributions[i]);await binFileUtils__namespace.endWriteSection(e)}function hashG1(e,t,a){const i=new Uint8Array(2*t.G1.F.n8);t.G1.toRprUncompressed(i,0,a),e.update(i)}function hashG2(e,t,a){const i=new Uint8Array(2*t.G2.F.n8);t.G2.toRprUncompressed(i,0,a),e.update(i)}function hashPubKey(e,t,a){hashG1(e,t,a.deltaAfter),hashG1(e,t,a.delta.g1_s),hashG1(e,t,a.delta.g1_sx),hashG2(e,t,a.delta.g2_spx),e.update(a.transcript)}async function write(e,t,a){await binFileUtils__namespace.startWriteSection(e,1);const i=8*(Math.floor((ffjavascript.Scalar.bitLength(a)-1)/64)+1);await e.writeULE32(i),await binFileUtils__namespace.writeBigInt(e,a,i),await e.writeULE32(t.length),await binFileUtils__namespace.endWriteSection(e),await binFileUtils__namespace.startWriteSection(e,2);for(let n=0;n<t.length;n++)await binFileUtils__namespace.writeBigInt(e,t[n],i);await binFileUtils__namespace.endWriteSection(e,2)}async function writeBin(e,t,a){await binFileUtils__namespace.startWriteSection(e,1);const i=8*(Math.floor((ffjavascript.Scalar.bitLength(a)-1)/64)+1);if(await e.writeULE32(i),await binFileUtils__namespace.writeBigInt(e,a,i),t.byteLength%i!=0)throw new Error("Invalid witness length");await e.writeULE32(t.byteLength/i),await binFileUtils__namespace.endWriteSection(e),await binFileUtils__namespace.startWriteSection(e,2),await e.write(t),await binFileUtils__namespace.endWriteSection(e)}async function readHeader(e,t){await binFileUtils__namespace.startReadUniqueSection(e,t,1);const a=await e.readULE32(),i=await binFileUtils__namespace.readBigInt(e,a),n=await e.readULE32();return await binFileUtils__namespace.endReadSection(e),{n8:a,q:i,nWitness:n}}async function read(e){const{fd:t,sections:a}=await binFileUtils__namespace.readBinFile(e,"wtns",2),{n8:i,nWitness:n}=await readHeader(t,a);await binFileUtils__namespace.startReadUniqueSection(t,a,2);const r=[];for(let o=0;o<n;o++){const e=await binFileUtils__namespace.readBigInt(t,i);r.push(e)}return await binFileUtils__namespace.endReadSection(t),await t.close(),r}const{stringifyBigInts:stringifyBigInts$2}=ffjavascript.utils;async function groth16Prove(e,t,a){const{fd:i,sections:n}=await binFileUtils__namespace.readBinFile(t,"wtns",2,1<<25,1<<23),r=await readHeader(i,n),{fd:o,sections:s}=await binFileUtils__namespace.readBinFile(e,"zkey",2,1<<25,1<<23),l=await readHeader$1(o,s);if("groth16"!=l.protocol)throw new Error("zkey file is not groth16");if(!ffjavascript.Scalar.eq(l.r,r.q))throw new Error("Curve of the witness does not match the curve of the proving key");if(r.nWitness!=l.nVars)throw new Error(`Invalid witness length. Circuit: ${l.nVars}, witness: ${r.nWitness}`);const c=l.curve,u=c.Fr,f=c.G1,d=c.G2,w=log2(l.domainSize);a&&a.debug("Reading Wtns");const p=await binFileUtils__namespace.readSection(i,n,2);a&&a.debug("Reading Coeffs");const m=await binFileUtils__namespace.readSection(o,s,4);a&&a.debug("Building ABC");const[b,g,h]=await buildABC1(c,l,p,m,a),_=w==u.s?c.Fr.shift:c.Fr.w[w+1],y=await u.ifft(b,"","",a,"IFFT_A"),F=await u.batchApplyKey(y,u.e(1),_),v=await u.fft(F,"","",a,"FFT_A"),G=await u.ifft(g,"","",a,"IFFT_B"),U=await u.batchApplyKey(G,u.e(1),_),S=await u.fft(U,"","",a,"FFT_B"),B=await u.ifft(h,"","",a,"IFFT_C"),E=await u.batchApplyKey(B,u.e(1),_),x=await u.fft(E,"","",a,"FFT_C");a&&a.debug("Join ABC");const k=await joinABC(c,l,v,S,x,a);let A={};a&&a.debug("Reading A Points");const C=await binFileUtils__namespace.readSection(o,s,5);A.pi_a=await c.G1.multiExpAffine(C,p,a,"multiexp A"),a&&a.debug("Reading B1 Points");const L=await binFileUtils__namespace.readSection(o,s,6);let R=await c.G1.multiExpAffine(L,p,a,"multiexp B1");a&&a.debug("Reading B2 Points");const z=await binFileUtils__namespace.readSection(o,s,7);A.pi_b=await c.G2.multiExpAffine(z,p,a,"multiexp B2"),a&&a.debug("Reading C Points");const T=await binFileUtils__namespace.readSection(o,s,8);A.pi_c=await c.G1.multiExpAffine(T,p.slice((l.nPublic+1)*c.Fr.n8),a,"multiexp C"),a&&a.debug("Reading H Points");const I=await binFileUtils__namespace.readSection(o,s,9),P=await c.G1.multiExpAffine(I,k,a,"multiexp H"),$=c.Fr.random(),j=c.Fr.random();A.pi_a=f.add(A.pi_a,l.vk_alpha_1),A.pi_a=f.add(A.pi_a,f.timesFr(l.vk_delta_1,$)),A.pi_b=d.add(A.pi_b,l.vk_beta_2),A.pi_b=d.add(A.pi_b,d.timesFr(l.vk_delta_2,j)),R=f.add(R,l.vk_beta_1),R=f.add(R,f.timesFr(l.vk_delta_1,j)),A.pi_c=f.add(A.pi_c,P),A.pi_c=f.add(A.pi_c,f.timesFr(A.pi_a,j)),A.pi_c=f.add(A.pi_c,f.timesFr(R,$)),A.pi_c=f.add(A.pi_c,f.timesFr(l.vk_delta_1,u.neg(u.mul($,j))));let H=[];for(let O=1;O<=l.nPublic;O++){const e=p.slice(O*u.n8,O*u.n8+u.n8);H.push(ffjavascript.Scalar.fromRprLE(e))}return A.pi_a=f.toObject(f.toAffine(A.pi_a)),A.pi_b=d.toObject(d.toAffine(A.pi_b)),A.pi_c=f.toObject(f.toAffine(A.pi_c)),A.protocol="groth16",A.curve=c.name,await o.close(),await i.close(),A=stringifyBigInts$2(A),H=stringifyBigInts$2(H),{proof:A,publicSignals:H}}async function buildABC1(e,t,a,i,n){const r=e.Fr.n8,o=12+t.n8r,s=(i.byteLength-4)/o,l=new ffjavascript.BigBuffer(t.domainSize*r),c=new ffjavascript.BigBuffer(t.domainSize*r),u=new ffjavascript.BigBuffer(t.domainSize*r),f=[l,c];for(let d=0;d<s;d++){n&&d%1e6==0&&n.debug(`QAP AB: ${d}/${s}`);const t=i.slice(4+d*o,4+d*o+o),l=new DataView(t.buffer),c=l.getUint32(0,!0),u=l.getUint32(4,!0),w=l.getUint32(8,!0),p=t.slice(12,12+r);f[c].set(e.Fr.add(f[c].slice(u*r,u*r+r),e.Fr.mul(p,a.slice(w*r,w*r+r))),u*r)}for(let d=0;d<t.domainSize;d++)n&&d%1e6==0&&n.debug(`QAP C: ${d}/${t.domainSize}`),u.set(e.Fr.mul(l.slice(d*r,d*r+r),c.slice(d*r,d*r+r)),d*r);return[l,c,u]}async function joinABC(e,t,a,i,n,r){const o=1<<22,s=e.Fr.n8,l=Math.floor(a.byteLength/e.Fr.n8),c=[];for(let w=0;w<l;w+=o){r&&r.debug(`JoinABC: ${w}/${l}`);const t=Math.min(l-w,o),u=[],f=a.slice(w*s,(w+t)*s),d=i.slice(w*s,(w+t)*s),p=n.slice(w*s,(w+t)*s);u.push({cmd:"ALLOCSET",var:0,buff:f}),u.push({cmd:"ALLOCSET",var:1,buff:d}),u.push({cmd:"ALLOCSET",var:2,buff:p}),u.push({cmd:"ALLOC",var:3,len:t*s}),u.push({cmd:"CALL",fnName:"qap_joinABC",params:[{var:0},{var:1},{var:2},{val:t},{var:3}]}),u.push({cmd:"CALL",fnName:"frm_batchFromMontgomery",params:[{var:3},{val:t},{var:3}]}),u.push({cmd:"GET",out:0,var:3,len:t*s}),c.push(e.tm.queueAction(u))}const u=await Promise.all(c);let f;f=a instanceof ffjavascript.BigBuffer?new ffjavascript.BigBuffer(a.byteLength):new Uint8Array(a.byteLength);let d=0;for(let w=0;w<u.length;w++)f.set(u[w][0],d),d+=u[w][0].byteLength;return f}const{unstringifyBigInts:unstringifyBigInts$7}=ffjavascript.utils;async function wtnsCalculate(e,t,a,i){const n=unstringifyBigInts$7(e),r=await fastFile__namespace.readExisting(t),o=await r.read(r.totalSize);await r.close();const s=await circom_runtime.WitnessCalculatorBuilder(o);if(1==s.circom_version()){const e=await s.calculateBinWitness(n),t=await binFileUtils__namespace.createBinFile(a,"wtns",2,2);await writeBin(t,e,s.prime),await t.close()}else{const e=await fastFile__namespace.createOverride(a),t=await s.calculateWTNSBin(n);await e.write(t),await e.close()}}const{unstringifyBigInts:unstringifyBigInts$6}=ffjavascript.utils;async function groth16FullProve(e,t,a,i){const n=unstringifyBigInts$6(e),r={type:"mem"};return await wtnsCalculate(n,t,r),await groth16Prove(a,r,i)}const{unstringifyBigInts:unstringifyBigInts$5}=ffjavascript.utils;async function groth16Verify(e,t,a,i){const n=unstringifyBigInts$5(e),r=unstringifyBigInts$5(a),o=unstringifyBigInts$5(t),s=await getCurveFromName(n.curve),l=s.G1.fromObject(n.IC[0]),c=new Uint8Array(2*s.G1.F.n8*o.length),u=new Uint8Array(s.Fr.n8*o.length);for(let _=0;_<o.length;_++){const e=s.G1.fromObject(n.IC[_+1]);c.set(e,_*s.G1.F.n8*2),ffjavascript.Scalar.toRprLE(u,s.Fr.n8*_,o[_],s.Fr.n8)}let f=await s.G1.multiExpAffine(c,u);f=s.G1.add(f,l);const d=s.G1.fromObject(r.pi_a),w=s.G2.fromObject(r.pi_b),p=s.G1.fromObject(r.pi_c),m=s.G2.fromObject(n.vk_gamma_2),b=s.G2.fromObject(n.vk_delta_2),g=s.G1.fromObject(n.vk_alpha_1),h=s.G2.fromObject(n.vk_beta_2);return await s.pairingEq(s.G1.neg(d),w,f,m,p,b,g,h)?(i&&i.info("OK!"),!0):(i&&i.error("Invalid proof"),!1)}const{unstringifyBigInts:unstringifyBigInts$4}=ffjavascript.utils;function p256$1(e){let t=e.toString(16);for(;t.length<64;)t="0"+t;return t=`"0x${t}"`,t}async function groth16ExportSolidityCallData(e,t){const a=unstringifyBigInts$4(e),i=unstringifyBigInts$4(t);let n,r="";for(let o=0;o<i.length;o++)""!=r&&(r+=","),r+=p256$1(i[o]);return n=`[${p256$1(a.pi_a[0])}, ${p256$1(a.pi_a[1])}],[[${p256$1(a.pi_b[0][1])}, ${p256$1(a.pi_b[0][0])}],[${p256$1(a.pi_b[1][1])}, ${p256$1(a.pi_b[1][0])}]],[${p256$1(a.pi_c[0])}, ${p256$1(a.pi_c[1])}],[${r}]`,n}var groth16=Object.freeze({__proto__:null,fullProve:groth16FullProve,prove:groth16Prove,verify:groth16Verify,exportSolidityCallData:groth16ExportSolidityCallData});function hashToG2(e,t){const a=new DataView(t.buffer,t.byteOffset,t.byteLength),i=[];for(let r=0;r<8;r++)i[r]=a.getUint32(4*r);const n=new ffjavascript.ChaCha(i);return e.G2.fromRng(n)}function getG2sp(e,t,a,i,n){const r=Blake2b__default.default(64),o=new Uint8Array([t]);r.update(o),r.update(a);const s=e.G1.toUncompressed(i);r.update(s);const l=e.G1.toUncompressed(n);r.update(l);return hashToG2(e,r.digest())}function calculatePubKey(e,t,a,i,n){return e.g1_s=t.G1.toAffine(t.G1.fromRng(n)),e.g1_sx=t.G1.toAffine(t.G1.timesFr(e.g1_s,e.prvKey)),e.g2_sp=t.G2.toAffine(getG2sp(t,a,i,e.g1_s,e.g1_sx)),e.g2_spx=t.G2.toAffine(t.G2.timesFr(e.g2_sp,e.prvKey)),e}function createPTauKey(e,t,a){const i={tau:{},alpha:{},beta:{}};return i.tau.prvKey=e.Fr.fromRng(a),i.alpha.prvKey=e.Fr.fromRng(a),i.beta.prvKey=e.Fr.fromRng(a),calculatePubKey(i.tau,e,0,t,a),calculatePubKey(i.alpha,e,1,t,a),calculatePubKey(i.beta,e,2,t,a),i}async function writePTauHeader(e,t,a,i){i||(i=a),await e.writeULE32(1);const n=e.pos;await e.writeULE64(0),await e.writeULE32(8*t.F1.n64);const r=new Uint8Array(t.F1.n8);ffjavascript.Scalar.toRprLE(r,0,t.q,t.F1.n8),await e.write(r),await e.writeULE32(a),await e.writeULE32(i);const o=e.pos-n-8,s=e.pos;await e.writeULE64(o,n),e.pos=s}async function readPTauHeader(e,t){if(!t[1])throw new Error(e.fileName+": File has no  header");if(t[1].length>1)throw new Error(e.fileName+": File has more than one header");e.pos=t[1][0].p;const a=await e.readULE32(),i=await e.read(a),n=ffjavascript.Scalar.fromRprLE(i),r=await getCurveFromQ(n);if(8*r.F1.n64!=a)throw new Error(e.fileName+": Invalid size");const o=await e.readULE32(),s=await e.readULE32();if(e.pos-t[1][0].p!=t[1][0].size)throw new Error("Invalid PTau header size");return{curve:r,power:o,ceremonyPower:s}}async function readPtauPubKey(e,t,a){return fromPtauPubKeyRpr(await e.read(2*t.F1.n8*6+2*t.F2.n8*3),0,t,a)}function fromPtauPubKeyRpr(e,t,a,i){const n={tau:{},alpha:{},beta:{}};return n.tau.g1_s=r(),n.tau.g1_sx=r(),n.alpha.g1_s=r(),n.alpha.g1_sx=r(),n.beta.g1_s=r(),n.beta.g1_sx=r(),n.tau.g2_spx=o(),n.alpha.g2_spx=o(),n.beta.g2_spx=o(),n;function r(){let n;return n=i?a.G1.fromRprLEM(e,t):a.G1.fromRprUncompressed(e,t),t+=2*a.G1.F.n8,n}function o(){let n;return n=i?a.G2.fromRprLEM(e,t):a.G2.fromRprUncompressed(e,t),t+=2*a.G2.F.n8,n}}function toPtauPubKeyRpr(e,t,a,i,n){async function r(i){n?a.G1.toRprLEM(e,t,i):a.G1.toRprUncompressed(e,t,i),t+=2*a.F1.n8}async function o(i){n?a.G2.toRprLEM(e,t,i):a.G2.toRprUncompressed(e,t,i),t+=2*a.F2.n8}return r(i.tau.g1_s),r(i.tau.g1_sx),r(i.alpha.g1_s),r(i.alpha.g1_sx),r(i.beta.g1_s),r(i.beta.g1_sx),o(i.tau.g2_spx),o(i.alpha.g2_spx),o(i.beta.g2_spx),e}async function writePtauPubKey(e,t,a,i){const n=new Uint8Array(2*t.F1.n8*6+2*t.F2.n8*3);toPtauPubKeyRpr(n,0,t,a,i),await e.write(n)}async function readContribution(e,t){const a={};a.tauG1=await l(),a.tauG2=await c(),a.alphaG1=await l(),a.betaG1=await l(),a.betaG2=await c(),a.key=await readPtauPubKey(e,t,!0),a.partialHash=await e.read(216),a.nextChallenge=await e.read(64),a.type=await e.readULE32();const i=new Uint8Array(2*t.G1.F.n8*6+2*t.G2.F.n8*3);toPtauPubKeyRpr(i,0,t,a.key,!1);const n=Blake2b__default.default(64);n.setPartialHash(a.partialHash),n.update(i),a.responseHash=n.digest();const r=await e.readULE32(),o=e.pos;let s=0;for(;e.pos-o<r;){const e=await u(1);if(e[0]<=s)throw new Error("Parameters in the contribution must be sorted");if(s=e[0],1==e[0]){const e=await u(1),t=await u(e[0]);a.name=(new TextDecoder).decode(t)}else if(2==e[0]){const e=await u(1);a.numIterationsExp=e[0]}else{if(3!=e[0])throw new Error("Parameter not recognized");{const e=await u(1);a.beaconHash=await u(e[0])}}}if(e.pos!=o+r)throw new Error("Parametes do not match");return a;async function l(){const a=await e.read(2*t.G1.F.n8);return t.G1.fromRprLEM(a)}async function c(){const a=await e.read(2*t.G2.F.n8);return t.G2.fromRprLEM(a)}async function u(t){const a=await e.read(t);return new Uint8Array(a)}}async function readContributions(e,t,a){if(!a[7])throw new Error(e.fileName+": File has no  contributions");if(a[7][0].length>1)throw new Error(e.fileName+": File has more than one contributions section");e.pos=a[7][0].p;const i=await e.readULE32(),n=[];for(let r=0;r<i;r++){const a=await readContribution(e,t);a.id=r+1,n.push(a)}if(e.pos-a[7][0].p!=a[7][0].size)throw new Error("Invalid contribution section size");return n}async function writeContribution(e,t,a){const i=new Uint8Array(2*t.F1.n8),n=new Uint8Array(2*t.F2.n8);await o(a.tauG1),await s(a.tauG2),await o(a.alphaG1),await o(a.betaG1),await s(a.betaG2),await writePtauPubKey(e,t,a.key,!0),await e.write(a.partialHash),await e.write(a.nextChallenge),await e.writeULE32(a.type||0);const r=[];if(a.name){r.push(1);const e=new TextEncoder("utf-8").encode(a.name.substring(0,64));r.push(e.byteLength);for(let t=0;t<e.byteLength;t++)r.push(e[t])}if(1==a.type){r.push(2),r.push(a.numIterationsExp),r.push(3),r.push(a.beaconHash.byteLength);for(let e=0;e<a.beaconHash.byteLength;e++)r.push(a.beaconHash[e])}if(r.length>0){const t=new Uint8Array(r);await e.writeULE32(t.byteLength),await e.write(t)}else await e.writeULE32(0);async function o(a){t.G1.toRprLEM(i,0,a),await e.write(i)}async function s(a){t.G2.toRprLEM(n,0,a),await e.write(n)}}async function writeContributions(e,t,a){await e.writeULE32(7);const i=e.pos;await e.writeULE64(0),await e.writeULE32(a.length);for(let o=0;o<a.length;o++)await writeContribution(e,t,a[o]);const n=e.pos-i-8,r=e.pos;await e.writeULE64(n,i),e.pos=r}function calculateFirstChallengeHash(e,t,a){a&&a.debug("Calculating First Challenge Hash");const i=new Blake2b__default.default(64),n=new Uint8Array(2*e.G1.F.n8),r=new Uint8Array(2*e.G2.F.n8);let o;return e.G1.toRprUncompressed(n,0,e.G1.g),e.G2.toRprUncompressed(r,0,e.G2.g),i.update(Blake2b__default.default(64).digest()),o=2**t*2-1,a&&a.debug("Calculate Initial Hash: tauG1"),s(n,o),o=2**t,a&&a.debug("Calculate Initial Hash: tauG2"),s(r,o),a&&a.debug("Calculate Initial Hash: alphaTauG1"),s(n,o),a&&a.debug("Calculate Initial Hash: betaTauG1"),s(n,o),i.update(r),i.digest();function s(e,t){const n=341e3,r=Math.floor(t/n),o=t%n,s=new Uint8Array(n*e.byteLength);for(let a=0;a<n;a++)s.set(e,a*e.byteLength);for(let l=0;l<r;l++)i.update(s),a&&a.debug("Initial hash: "+l*n);for(let a=0;a<o;a++)i.update(e)}}function keyFromBeacon(e,t,a,i){return createPTauKey(e,t,rngFromBeaconParams(a,i))}async function newAccumulator(e,t,a,i){await Blake2b__default.default.ready();const n=await binFileUtils__namespace.createBinFile(a,"ptau",1,7);await writePTauHeader(n,e,t,0);const r=e.G1.oneAffine,o=e.G2.oneAffine;await binFileUtils__namespace.startWriteSection(n,2);const s=2**t*2-1;for(let d=0;d<s;d++)await n.write(r),i&&d%1e5==0&&d&&i.log("tauG1: "+d);await binFileUtils__namespace.endWriteSection(n),await binFileUtils__namespace.startWriteSection(n,3);const l=2**t;for(let d=0;d<l;d++)await n.write(o),i&&d%1e5==0&&d&&i.log("tauG2: "+d);await binFileUtils__namespace.endWriteSection(n),await binFileUtils__namespace.startWriteSection(n,4);const c=2**t;for(let d=0;d<c;d++)await n.write(r),i&&d%1e5==0&&d&&i.log("alphaTauG1: "+d);await binFileUtils__namespace.endWriteSection(n),await binFileUtils__namespace.startWriteSection(n,5);const u=2**t;for(let d=0;d<u;d++)await n.write(r),i&&d%1e5==0&&d&&i.log("betaTauG1: "+d);await binFileUtils__namespace.endWriteSection(n),await binFileUtils__namespace.startWriteSection(n,6),await n.write(o),await binFileUtils__namespace.endWriteSection(n),await binFileUtils__namespace.startWriteSection(n,7),await n.writeULE32(0),await binFileUtils__namespace.endWriteSection(n),await n.close();const f=calculateFirstChallengeHash(e,t,i);return i&&i.debug(formatHash(Blake2b__default.default(64).digest(),"Blank Contribution Hash:")),i&&i.info(formatHash(f,"First Contribution Hash:")),f}async function exportChallenge(e,t,a){await Blake2b__default.default.ready();const{fd:i,sections:n}=await binFileUtils__namespace.readBinFile(e,"ptau",1),{curve:r,power:o}=await readPTauHeader(i,n),s=await readContributions(i,r,n);let l,c;0==s.length?(l=Blake2b__default.default(64).digest(),c=calculateFirstChallengeHash(r,o)):(l=s[s.length-1].responseHash,c=s[s.length-1].nextChallenge),a&&a.info(formatHash(l,"Last Response Hash: ")),a&&a.info(formatHash(c,"New Challenge Hash: "));const u=await fastFile__namespace.createOverride(t),f=Blake2b__default.default(64);await u.write(l),f.update(l),await w(2,"G1",2**o*2-1,"tauG1"),await w(3,"G2",2**o,"tauG2"),await w(4,"G1",2**o,"alphaTauG1"),await w(5,"G1",2**o,"betaTauG1"),await w(6,"G2",1,"betaG2"),await i.close(),await u.close();const d=f.digest();if(!hashIsEqual(c,d))throw a&&a.info(formatHash(d,"Calc Curret Challenge Hash: ")),a&&a.error("PTau file is corrupted. Calculated new challenge hash does not match with the eclared one"),new Error("PTau file is corrupted. Calculated new challenge hash does not match with the eclared one");return c;async function w(e,t,o,s){const l=r[t],c=2*l.F.n8,d=Math.floor((1<<24)/c);await binFileUtils__namespace.startReadUniqueSection(i,n,e);for(let n=0;n<o;n+=d){a&&a.debug(`Exporting ${s}: ${n}/${o}`);const e=Math.min(o-n,d);let t;t=await i.read(e*c),t=await l.batchLEMtoU(t),await u.write(t),f.update(t)}await binFileUtils__namespace.endReadSection(i)}}async function importResponse(e,t,a,i,n,r){await Blake2b__default.default.ready();const o=new Uint8Array(64);for(let x=0;x<64;x++)o[x]=255;const{fd:s,sections:l}=await binFileUtils__namespace.readBinFile(e,"ptau",1),{curve:c,power:u}=await readPTauHeader(s,l),f=await readContributions(s,c,l),d={};i&&(d.name=i);const w=2*c.F1.n8,p=c.F1.n8,m=2*c.F2.n8,b=c.F2.n8,g=await fastFile__namespace.readExisting(t);if(g.totalSize!=64+(2**u*2-1)*p+2**u*b+2**u*p+2**u*p+b+6*w+3*m)throw new Error("Size of the contribution is invalid");let h;h=f.length>0?f[f.length-1].nextChallenge:calculateFirstChallengeHash(c,u,r);const _=await binFileUtils__namespace.createBinFile(a,"ptau",1,n?7:2);await writePTauHeader(_,c,u);const y=await g.read(64);if(hashIsEqual(o,h)&&(h=y,f[f.length-1].nextChallenge=h),!hashIsEqual(y,h))throw new Error("Wrong contribution. this contribution is not based on the previus hash");const F=new Blake2b__default.default(64);F.update(y);const v=[];let G;G=await B(g,_,"G1",2,2**u*2-1,[1],"tauG1"),d.tauG1=G[0],G=await B(g,_,"G2",3,2**u,[1],"tauG2"),d.tauG2=G[0],G=await B(g,_,"G1",4,2**u,[0],"alphaG1"),d.alphaG1=G[0],G=await B(g,_,"G1",5,2**u,[0],"betaG1"),d.betaG1=G[0],G=await B(g,_,"G2",6,1,[0],"betaG2"),d.betaG2=G[0],d.partialHash=F.getPartialHash();const U=await g.read(2*c.F1.n8*6+2*c.F2.n8*3);d.key=fromPtauPubKeyRpr(U,0,c,!1),F.update(new Uint8Array(U));const S=F.digest();if(r&&r.info(formatHash(S,"Contribution Response Hash imported: ")),n){const e=new Blake2b__default.default(64);e.update(S),await E(e,_,"G1",2,2**u*2-1,"tauG1",r),await E(e,_,"G2",3,2**u,"tauG2",r),await E(e,_,"G1",4,2**u,"alphaTauG1",r),await E(e,_,"G1",5,2**u,"betaTauG1",r),await E(e,_,"G2",6,1,"betaG2",r),d.nextChallenge=e.digest(),r&&r.info(formatHash(d.nextChallenge,"Next Challenge Hash: "))}else d.nextChallenge=o;return f.push(d),await writeContributions(_,c,f),await g.close(),await _.close(),await s.close(),d.nextChallenge;async function B(e,t,a,i,o,s,l){return n?await async function(e,t,a,i,n,o,s){const l=c[a],u=l.F.n8,f=2*l.F.n8,d=[];await binFileUtils__namespace.startWriteSection(t,i);const w=Math.floor((1<<24)/f);v[i]=t.pos;for(let c=0;c<n;c+=w){r&&r.debug(`Importing ${s}: ${c}/${n}`);const a=Math.min(n-c,w),i=await e.read(a*u);F.update(i);const p=await l.batchCtoLEM(i);await t.write(p);for(let e=0;e<o.length;e++){const t=o[e];if(t>=c&&t<c+a){const e=l.fromRprLEM(p,(t-c)*f);d.push(e)}}}return await binFileUtils__namespace.endWriteSection(t),d}(e,t,a,i,o,s,l):await async function(e,t,a,i,n,o,s){const l=c[a],u=l.F.n8,f=[],d=Math.floor((1<<24)/u);for(let c=0;c<n;c+=d){r&&r.debug(`Importing ${s}: ${c}/${n}`);const t=Math.min(n-c,d),a=await e.read(t*u);F.update(a);for(let e=0;e<o.length;e++){const i=o[e];if(i>=c&&i<c+t){const e=l.fromRprCompressed(a,(i-c)*u);f.push(e)}}}return f}(e,0,a,0,o,s,l)}async function E(e,t,a,i,n,r,o){const s=c[a],l=2*s.F.n8,u=Math.floor((1<<24)/l),f=t.pos;t.pos=v[i];for(let c=0;c<n;c+=u){o&&o.debug(`Hashing ${r}: ${c}/${n}`);const a=Math.min(n-c,u),i=await t.read(a*l),f=await s.batchLEMtoU(i);e.update(f)}t.pos=f}}const sameRatio$1=sameRatio$2;async function verifyContribution(e,t,a,i){let n;if(1==t.type){const n=keyFromBeacon(e,a.nextChallenge,t.beaconHash,t.numIterationsExp);if(!e.G1.eq(t.key.tau.g1_s,n.tau.g1_s))return i&&i.error(`BEACON key (tauG1_s) is not generated correctly in challenge #${t.id}  ${t.name||""}`),!1;if(!e.G1.eq(t.key.tau.g1_sx,n.tau.g1_sx))return i&&i.error(`BEACON key (tauG1_sx) is not generated correctly in challenge #${t.id}  ${t.name||""}`),!1;if(!e.G2.eq(t.key.tau.g2_spx,n.tau.g2_spx))return i&&i.error(`BEACON key (tauG2_spx) is not generated correctly in challenge #${t.id}  ${t.name||""}`),!1;if(!e.G1.eq(t.key.alpha.g1_s,n.alpha.g1_s))return i&&i.error(`BEACON key (alphaG1_s) is not generated correctly in challenge #${t.id}  ${t.name||""}`),!1;if(!e.G1.eq(t.key.alpha.g1_sx,n.alpha.g1_sx))return i&&i.error(`BEACON key (alphaG1_sx) is not generated correctly in challenge #${t.id}  ${t.name||""}`),!1;if(!e.G2.eq(t.key.alpha.g2_spx,n.alpha.g2_spx))return i&&i.error(`BEACON key (alphaG2_spx) is not generated correctly in challenge #${t.id}  ${t.name||""}`),!1;if(!e.G1.eq(t.key.beta.g1_s,n.beta.g1_s))return i&&i.error(`BEACON key (betaG1_s) is not generated correctly in challenge #${t.id}  ${t.name||""}`),!1;if(!e.G1.eq(t.key.beta.g1_sx,n.beta.g1_sx))return i&&i.error(`BEACON key (betaG1_sx) is not generated correctly in challenge #${t.id}  ${t.name||""}`),!1;if(!e.G2.eq(t.key.beta.g2_spx,n.beta.g2_spx))return i&&i.error(`BEACON key (betaG2_spx) is not generated correctly in challenge #${t.id}  ${t.name||""}`),!1}return t.key.tau.g2_sp=e.G2.toAffine(getG2sp(e,0,a.nextChallenge,t.key.tau.g1_s,t.key.tau.g1_sx)),t.key.alpha.g2_sp=e.G2.toAffine(getG2sp(e,1,a.nextChallenge,t.key.alpha.g1_s,t.key.alpha.g1_sx)),t.key.beta.g2_sp=e.G2.toAffine(getG2sp(e,2,a.nextChallenge,t.key.beta.g1_s,t.key.beta.g1_sx)),n=await sameRatio$1(e,t.key.tau.g1_s,t.key.tau.g1_sx,t.key.tau.g2_sp,t.key.tau.g2_spx),!0!==n?(i&&i.error("INVALID key (tau) in challenge #"+t.id),!1):(n=await sameRatio$1(e,t.key.alpha.g1_s,t.key.alpha.g1_sx,t.key.alpha.g2_sp,t.key.alpha.g2_spx),!0!==n?(i&&i.error("INVALID key (alpha) in challenge #"+t.id),!1):(n=await sameRatio$1(e,t.key.beta.g1_s,t.key.beta.g1_sx,t.key.beta.g2_sp,t.key.beta.g2_spx),!0!==n?(i&&i.error("INVALID key (beta) in challenge #"+t.id),!1):(n=await sameRatio$1(e,a.tauG1,t.tauG1,t.key.tau.g2_sp,t.key.tau.g2_spx),!0!==n?(i&&i.error("INVALID tau*G1. challenge #"+t.id+" It does not follow the previous contribution"),!1):(n=await sameRatio$1(e,t.key.tau.g1_s,t.key.tau.g1_sx,a.tauG2,t.tauG2),!0!==n?(i&&i.error("INVALID tau*G2. challenge #"+t.id+" It does not follow the previous contribution"),!1):(n=await sameRatio$1(e,a.alphaG1,t.alphaG1,t.key.alpha.g2_sp,t.key.alpha.g2_spx),!0!==n?(i&&i.error("INVALID alpha*G1. challenge #"+t.id+" It does not follow the previous contribution"),!1):(n=await sameRatio$1(e,a.betaG1,t.betaG1,t.key.beta.g2_sp,t.key.beta.g2_spx),!0!==n?(i&&i.error("INVALID beta*G1. challenge #"+t.id+" It does not follow the previous contribution"),!1):(n=await sameRatio$1(e,t.key.beta.g1_s,t.key.beta.g1_sx,a.betaG2,t.betaG2),!0!==n?(i&&i.error("INVALID beta*G2. challenge #"+t.id+"It does not follow the previous contribution"),!1):(i&&i.info("Powers Of tau file OK!"),!0))))))))}async function verify(e,t){let a;await Blake2b__default.default.ready();const{fd:i,sections:n}=await binFileUtils__namespace.readBinFile(e,"ptau",1),{curve:r,power:o,ceremonyPower:s}=await readPTauHeader(i,n),l=await readContributions(i,r,n);t&&t.debug("power: 2**"+o),t&&t.debug("Computing initial contribution hash");const c={tauG1:r.G1.g,tauG2:r.G2.g,alphaG1:r.G1.g,betaG1:r.G1.g,betaG2:r.G2.g,nextChallenge:calculateFirstChallengeHash(r,s,t),responseHash:Blake2b__default.default(64).digest()};if(0==l.length)return t&&t.error("This file has no contribution! It cannot be used in production"),!1;let u;u=l.length>1?l[l.length-2]:c;const f=l[l.length-1];t&&t.debug("Validating contribution #"+l[l.length-1].id);if(!await verifyContribution(r,f,u,t))return!1;const d=Blake2b__default.default(64);d.update(f.responseHash),t&&t.debug("Verifying powers in tau*G1 section");const w=await y(2,"G1","tauG1",2**o*2-1,[0,1],t);if(a=await sameRatio$1(r,w.R1,w.R2,r.G2.g,f.tauG2),!0!==a)return t&&t.error("tauG1 section. Powers do not match"),!1;if(!r.G1.eq(r.G1.g,w.singularPoints[0]))return t&&t.error("First element of tau*G1 section must be the generator"),!1;if(!r.G1.eq(f.tauG1,w.singularPoints[1]))return t&&t.error("Second element of tau*G1 section does not match the one in the contribution section"),!1;t&&t.debug("Verifying powers in tau*G2 section");const p=await y(3,"G2","tauG2",2**o,[0,1],t);if(a=await sameRatio$1(r,r.G1.g,f.tauG1,p.R1,p.R2),!0!==a)return t&&t.error("tauG2 section. Powers do not match"),!1;if(!r.G2.eq(r.G2.g,p.singularPoints[0]))return t&&t.error("First element of tau*G2 section must be the generator"),!1;if(!r.G2.eq(f.tauG2,p.singularPoints[1]))return t&&t.error("Second element of tau*G2 section does not match the one in the contribution section"),!1;t&&t.debug("Verifying powers in alpha*tau*G1 section");const m=await y(4,"G1","alphatauG1",2**o,[0],t);if(a=await sameRatio$1(r,m.R1,m.R2,r.G2.g,f.tauG2),!0!==a)return t&&t.error("alphaTauG1 section. Powers do not match"),!1;if(!r.G1.eq(f.alphaG1,m.singularPoints[0]))return t&&t.error("First element of alpha*tau*G1 section (alpha*G1) does not match the one in the contribution section"),!1;t&&t.debug("Verifying powers in beta*tau*G1 section");const b=await y(5,"G1","betatauG1",2**o,[0],t);if(a=await sameRatio$1(r,b.R1,b.R2,r.G2.g,f.tauG2),!0!==a)return t&&t.error("betaTauG1 section. Powers do not match"),!1;if(!r.G1.eq(f.betaG1,b.singularPoints[0]))return t&&t.error("First element of beta*tau*G1 section (beta*G1) does not match the one in the contribution section"),!1;const g=await async function(e){const t=r.G2,a=2*t.F.n8,o=new Uint8Array(a);if(!n[6])throw e.error("File has no BetaG2 section"),new Error("File has no BetaG2 section");if(n[6].length>1)throw e.error("File has no BetaG2 section"),new Error("File has more than one GetaG2 section");i.pos=n[6][0].p;const s=await i.read(a),l=t.fromRprLEM(s);return t.toRprUncompressed(o,0,l),d.update(o),l}(t);if(!r.G2.eq(f.betaG2,g))return t&&t.error("betaG2 element in betaG2 section does not match the one in the contribution section"),!1;const h=d.digest();if(o==s&&!hashIsEqual(h,f.nextChallenge))return t&&t.error("Hash of the values does not match the next challenge of the last contributor in the contributions section"),!1;t&&t.info(formatHash(h,"Next challenge hash: ")),_(f,u);for(let v=l.length-2;v>=0;v--){const e=l[v],a=v>0?l[v-1]:c;if(!await verifyContribution(r,e,a,t))return!1;_(e,a)}if(t&&t.info("-----------------------------------------------------"),n[12]&&n[13]&&n[14]&&n[15]){let e;if(e=await F("G1",2,12,"tauG1",t),!e)return!1;if(e=await F("G2",3,13,"tauG2",t),!e)return!1;if(e=await F("G1",4,14,"alphaTauG1",t),!e)return!1;if(e=await F("G1",5,15,"betaTauG1",t),!e)return!1}else t&&t.warn('this file does not contain phase2 precalculated values. Please run: \n   snarkjs "powersoftau preparephase2" to prepare this file to be used in the phase2 ceremony.');return await i.close(),t&&t.info("Powers of Tau Ok!"),!0;function _(e,a){if(!t)return;t.info("-----------------------------------------------------"),t.info(`Contribution #${e.id}: ${e.name||""}`),t.info(formatHash(e.nextChallenge,"Next Challenge: "));const i=new Uint8Array(2*r.G1.F.n8*6+2*r.G2.F.n8*3);toPtauPubKeyRpr(i,0,r,e.key,!1);const n=Blake2b__default.default(64);n.setPartialHash(e.partialHash),n.update(i);const o=n.digest();t.info(formatHash(o,"Response Hash:")),t.info(formatHash(a.nextChallenge,"Response Hash:")),1==e.type&&(t.info(`Beacon generator: ${byteArray2hex(e.beaconHash)}`),t.info(`Beacon iterations Exp: ${e.numIterationsExp}`))}async function y(e,t,a,o,s,l){const c=r[t],u=2*c.F.n8;await binFileUtils__namespace.startReadUniqueSection(i,n,e);const f=[];let w=c.zero,p=c.zero,m=c.zero;for(let n=0;n<o;n+=65536){l&&l.debug(`points relations: ${a}: ${n}/${o} `);const e=Math.min(o-n,65536),t=await i.read(e*u),r=await c.batchLEMtoU(t);d.update(r);const b=new Uint8Array(4*(e-1));if(crypto__default.default.randomFillSync(b),n>0){const e=c.fromRprLEM(t,0),a=crypto__default.default.randomBytes(4).readUInt32BE(0,!0);w=c.add(w,c.timesScalar(m,a)),p=c.add(p,c.timesScalar(e,a))}const g=await c.multiExpAffine(t.slice(0,(e-1)*u),b),h=await c.multiExpAffine(t.slice(u),b);w=c.add(w,g),p=c.add(p,h),m=c.fromRprLEM(t,(e-1)*u);for(let a=0;a<s.length;a++){const i=s[a];if(i>=n&&i<n+e){const e=c.fromRprLEM(t,(i-n)*u);f.push(e)}}}return await binFileUtils__namespace.endReadSection(i),{R1:w,R2:p,singularPoints:f}}async function F(e,t,a,s,l){l&&l.debug(`Verifying phase2 calculated values ${s}...`);const c=r[e],u=2*c.F.n8,f=new Array(8);for(let i=0;i<8;i++)f[i]=crypto__default.default.randomBytes(4).readUInt32BE(0,!0);for(let i=0;i<=o;i++){if(!await d(i))return!1}if(2==t){if(!await d(o+1))return!1}return!0;async function d(e){l&&l.debug(`Power ${e}...`);const d=r.Fr.n8,w=2**e;let p,m=new Uint32Array(w),b=new ffjavascript.ChaCha(f);l&&l.debug(`Creating random numbers Powers${e}...`);for(let t=0;t<w;t++)m[t]=e==o+1&&t==w-1?0:b.nextU32();m=new Uint8Array(m.buffer,m.byteOffset,m.byteLength),l&&l.debug(`reading points Powers${e}...`),await binFileUtils__namespace.startReadUniqueSection(i,n,t),p=new ffjavascript.BigBuffer(w*u),e==o+1?(await i.readToBuffer(p,0,(w-1)*u),p.set(r.G1.zeroAffine,(w-1)*u)):await i.readToBuffer(p,0,w*u),await binFileUtils__namespace.endReadSection(i,!0);const g=await c.multiExpAffine(p,m,l,s+"_"+e);m=new ffjavascript.BigBuffer(w*d),b=new ffjavascript.ChaCha(f);const h=new Uint8Array(4),_=new DataView(h.buffer);l&&l.debug(`Creating random numbers Powers${e}...`);for(let t=0;t<w;t++)t==w-1&&e==o+1||(_.setUint32(0,b.nextU32(),!0),m.set(h,t*d));l&&l.debug(`batchToMontgomery ${e}...`),m=await r.Fr.batchToMontgomery(m),l&&l.debug(`fft ${e}...`),m=await r.Fr.fft(m),l&&l.debug(`batchFromMontgomery ${e}...`),m=await r.Fr.batchFromMontgomery(m),l&&l.debug(`reading points Lagrange${e}...`),await binFileUtils__namespace.startReadUniqueSection(i,n,a),i.pos+=u*(2**e-1),await i.readToBuffer(p,0,w*u),await binFileUtils__namespace.endReadSection(i,!0);const y=await c.multiExpAffine(p,m,l,s+"_"+e+"_transformed");return!!c.eq(g,y)||(l&&l.error("Phase2 caclutation does not match with powers of tau"),!1)}}}async function applyKeyToSection(e,t,a,i,n,r,o,s,l,c){const u=n[r],f=2*u.F.n8,d=t[i][0].size/f;await binFileUtils__namespace.startReadUniqueSection(e,t,i),await binFileUtils__namespace.startWriteSection(a,i);let w=o;for(let p=0;p<d;p+=65536){c&&c.debug(`Applying key: ${l}: ${p}/${d}`);const t=Math.min(d-p,65536);let i;i=await e.read(t*f),i=await u.batchApplyKey(i,w,s),await a.write(i),w=n.Fr.mul(w,n.Fr.exp(s,t))}await binFileUtils__namespace.endWriteSection(a),await binFileUtils__namespace.endReadSection(e)}async function applyKeyToChallengeSection(e,t,a,i,n,r,o,s,l,c,u){const f=i[n],d=2*f.F.n8,w=Math.floor((1<<20)/d);let p=o;for(let m=0;m<r;m+=w){u&&u.debug(`Applying key ${c}: ${m}/${r}`);const n=Math.min(r-m,w),o=await e.read(n*d),b=await f.batchUtoLEM(o),g=await f.batchApplyKey(b,p,s);let h;h="COMPRESSED"==l?await f.batchLEMtoC(g):await f.batchLEMtoU(g),a&&a.update(h),await t.write(h),p=i.Fr.mul(p,i.Fr.exp(s,n))}}async function challengeContribute(e,t,a,i,n){await Blake2b__default.default.ready();const r=await fastFile__namespace.readExisting(t),o=8*e.F1.n64*2,s=8*e.F2.n64*2,l=(r.totalSize+o-64-s)/(4*o+s);let c=l,u=0;for(;c>1;)c/=2,u+=1;if(2**u!=l)throw new Error("Invalid file size");n&&n.debug("Power to tau size: "+u);const f=await getRandomRng(i),d=await fastFile__namespace.createOverride(a),w=Blake2b__default.default(64);for(let y=0;y<r.totalSize;y+=r.pageSize){n&&n.debug(`Hashing challenge ${y}/${r.totalSize}`);const e=Math.min(r.totalSize-y,r.pageSize),t=await r.read(e);w.update(t)}const p=await r.read(64,0);n&&n.info(formatHash(p,"Claimed Previous Response Hash: "));const m=w.digest();n&&n.info(formatHash(m,"Current Challenge Hash: "));const b=createPTauKey(e,m,f);n&&["tau","alpha","beta"].forEach((t=>{n.debug(t+".g1_s: "+e.G1.toString(b[t].g1_s,16)),n.debug(t+".g1_sx: "+e.G1.toString(b[t].g1_sx,16)),n.debug(t+".g2_sp: "+e.G2.toString(b[t].g2_sp,16)),n.debug(t+".g2_spx: "+e.G2.toString(b[t].g2_spx,16)),n.debug("")}));const g=Blake2b__default.default(64);await d.write(m),g.update(m),await applyKeyToChallengeSection(r,d,g,e,"G1",2**u*2-1,e.Fr.one,b.tau.prvKey,"COMPRESSED","tauG1",n),await applyKeyToChallengeSection(r,d,g,e,"G2",2**u,e.Fr.one,b.tau.prvKey,"COMPRESSED","tauG2",n),await applyKeyToChallengeSection(r,d,g,e,"G1",2**u,b.alpha.prvKey,b.tau.prvKey,"COMPRESSED","alphaTauG1",n),await applyKeyToChallengeSection(r,d,g,e,"G1",2**u,b.beta.prvKey,b.tau.prvKey,"COMPRESSED","betaTauG1",n),await applyKeyToChallengeSection(r,d,g,e,"G2",1,b.beta.prvKey,b.tau.prvKey,"COMPRESSED","betaTauG2",n);const h=new Uint8Array(2*e.F1.n8*6+2*e.F2.n8*3);toPtauPubKeyRpr(h,0,e,b,!1),await d.write(h),g.update(h);const _=g.digest();n&&n.info(formatHash(_,"Contribution Response Hash: ")),await d.close(),await r.close()}async function beacon$1(e,t,a,i,n,r){const o=hex2ByteArray(i);if(0==o.byteLength||2*o.byteLength!=i.length)return r&&r.error("Invalid Beacon Hash. (It must be a valid hexadecimal sequence)"),!1;if(o.length>=256)return r&&r.error("Maximum lenght of beacon hash is 255 bytes"),!1;if((n=parseInt(n))<10||n>63)return r&&r.error("Invalid numIterationsExp. (Must be between 10 and 63)"),!1;await Blake2b__default.default.ready();const{fd:s,sections:l}=await binFileUtils__namespace.readBinFile(e,"ptau",1),{curve:c,power:u,ceremonyPower:f}=await readPTauHeader(s,l);if(u!=f)return r&&r.error("This file has been reduced. You cannot contribute into a reduced file."),!1;l[12]&&r&&r.warn("Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.");const d=await readContributions(s,c,l),w={name:a,type:1,numIterationsExp:n,beaconHash:o};let p;p=d.length>0?d[d.length-1].nextChallenge:calculateFirstChallengeHash(c,u,r),w.key=keyFromBeacon(c,p,o,n);const m=new Blake2b__default.default(64);m.update(p);const b=await binFileUtils__namespace.createBinFile(t,"ptau",1,7);await writePTauHeader(b,c,u);const g=[];let h;h=await v(2,"G1",2**u*2-1,c.Fr.e(1),w.key.tau.prvKey,"tauG1",r),w.tauG1=h[1],h=await v(3,"G2",2**u,c.Fr.e(1),w.key.tau.prvKey,"tauG2",r),w.tauG2=h[1],h=await v(4,"G1",2**u,w.key.alpha.prvKey,w.key.tau.prvKey,"alphaTauG1",r),w.alphaG1=h[0],h=await v(5,"G1",2**u,w.key.beta.prvKey,w.key.tau.prvKey,"betaTauG1",r),w.betaG1=h[0],h=await v(6,"G2",1,w.key.beta.prvKey,w.key.tau.prvKey,"betaTauG2",r),w.betaG2=h[0],w.partialHash=m.getPartialHash();const _=new Uint8Array(2*c.F1.n8*6+2*c.F2.n8*3);toPtauPubKeyRpr(_,0,c,w.key,!1),m.update(new Uint8Array(_));const y=m.digest();r&&r.info(formatHash(y,"Contribution Response Hash imported: "));const F=new Blake2b__default.default(64);return F.update(y),await G(b,"G1",2,2**u*2-1,"tauG1",r),await G(b,"G2",3,2**u,"tauG2",r),await G(b,"G1",4,2**u,"alphaTauG1",r),await G(b,"G1",5,2**u,"betaTauG1",r),await G(b,"G2",6,1,"betaG2",r),w.nextChallenge=F.digest(),r&&r.info(formatHash(w.nextChallenge,"Next Challenge Hash: ")),d.push(w),await writeContributions(b,c,d),await s.close(),await b.close(),y;async function v(e,t,a,i,n,r,o){const u=[];s.pos=l[e][0].p,await binFileUtils__namespace.startWriteSection(b,e),g[e]=b.pos;const f=c[t],d=2*f.F.n8,w=Math.floor((1<<20)/d);let p=i;for(let l=0;l<a;l+=w){o&&o.debug(`applying key${r}: ${l}/${a}`);const e=Math.min(a-l,w),t=await s.read(e*d),i=await f.batchApplyKey(t,p,n),g=b.write(i),h=await f.batchLEMtoC(i);if(m.update(h),await g,0==l)for(let n=0;n<Math.min(2,a);n++)u.push(f.fromRprLEM(i,n*d));p=c.Fr.mul(p,c.Fr.exp(n,e))}return await binFileUtils__namespace.endWriteSection(b),u}async function G(e,t,a,i,n,r){const o=c[t],s=2*o.F.n8,l=Math.floor((1<<24)/s),u=e.pos;e.pos=g[a];for(let c=0;c<i;c+=l){r&&r.debug(`Hashing ${n}: ${c}/${i}`);const t=Math.min(i-c,l),a=await e.read(t*s),u=await o.batchLEMtoU(a);F.update(u)}e.pos=u}}async function contribute(e,t,a,i,n){await Blake2b__default.default.ready();const{fd:r,sections:o}=await binFileUtils__namespace.readBinFile(e,"ptau",1),{curve:s,power:l,ceremonyPower:c}=await readPTauHeader(r,o);if(l!=c)throw n&&n.error("This file has been reduced. You cannot contribute into a reduced file."),new Error("This file has been reduced. You cannot contribute into a reduced file.");o[12]&&n&&n.warn("WARNING: Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.");const u=await readContributions(r,s,o),f={name:a,type:0};let d;const w=await getRandomRng(i);d=u.length>0?u[u.length-1].nextChallenge:calculateFirstChallengeHash(s,l,n),f.key=createPTauKey(s,d,w);const p=new Blake2b__default.default(64);p.update(d);const m=await binFileUtils__namespace.createBinFile(t,"ptau",1,7);await writePTauHeader(m,s,l);const b=[];let g;g=await F(2,"G1",2**l*2-1,s.Fr.e(1),f.key.tau.prvKey,"tauG1"),f.tauG1=g[1],g=await F(3,"G2",2**l,s.Fr.e(1),f.key.tau.prvKey,"tauG2"),f.tauG2=g[1],g=await F(4,"G1",2**l,f.key.alpha.prvKey,f.key.tau.prvKey,"alphaTauG1"),f.alphaG1=g[0],g=await F(5,"G1",2**l,f.key.beta.prvKey,f.key.tau.prvKey,"betaTauG1"),f.betaG1=g[0],g=await F(6,"G2",1,f.key.beta.prvKey,f.key.tau.prvKey,"betaTauG2"),f.betaG2=g[0],f.partialHash=p.getPartialHash();const h=new Uint8Array(2*s.F1.n8*6+2*s.F2.n8*3);toPtauPubKeyRpr(h,0,s,f.key,!1),p.update(new Uint8Array(h));const _=p.digest();n&&n.info(formatHash(_,"Contribution Response Hash imported: "));const y=new Blake2b__default.default(64);return y.update(_),await v(m,"G1",2,2**l*2-1,"tauG1"),await v(m,"G2",3,2**l,"tauG2"),await v(m,"G1",4,2**l,"alphaTauG1"),await v(m,"G1",5,2**l,"betaTauG1"),await v(m,"G2",6,1,"betaG2"),f.nextChallenge=y.digest(),n&&n.info(formatHash(f.nextChallenge,"Next Challenge Hash: ")),u.push(f),await writeContributions(m,s,u),await r.close(),await m.close(),_;async function F(e,t,a,i,l,c){const u=[];r.pos=o[e][0].p,await binFileUtils__namespace.startWriteSection(m,e),b[e]=m.pos;const f=s[t],d=2*f.F.n8,w=Math.floor((1<<20)/d);let g=i;for(let o=0;o<a;o+=w){n&&n.debug(`processing: ${c}: ${o}/${a}`);const e=Math.min(a-o,w),t=await r.read(e*d),i=await f.batchApplyKey(t,g,l),b=m.write(i),h=await f.batchLEMtoC(i);if(p.update(h),await b,0==o)for(let n=0;n<Math.min(2,a);n++)u.push(f.fromRprLEM(i,n*d));g=s.Fr.mul(g,s.Fr.exp(l,e))}return await binFileUtils__namespace.endWriteSection(m),u}async function v(e,t,a,i,r){const o=s[t],l=2*o.F.n8,c=Math.floor((1<<24)/l),u=e.pos;e.pos=b[a];for(let s=0;s<i;s+=c){n&&s&&n.debug(`Hashing ${r}: `+s);const t=Math.min(i-s,c),a=await e.read(t*l),u=await o.batchLEMtoU(a);y.update(u)}e.pos=u}}async function preparePhase2(e,t,a){const{fd:i,sections:n}=await binFileUtils__namespace.readBinFile(e,"ptau",1),{curve:r,power:o}=await readPTauHeader(i,n),s=await binFileUtils__namespace.createBinFile(t,"ptau",1,11);return await writePTauHeader(s,r,o),await binFileUtils__namespace.copySection(i,n,s,2),await binFileUtils__namespace.copySection(i,n,s,3),await binFileUtils__namespace.copySection(i,n,s,4),await binFileUtils__namespace.copySection(i,n,s,5),await binFileUtils__namespace.copySection(i,n,s,6),await binFileUtils__namespace.copySection(i,n,s,7),await l(2,12,"G1","tauG1"),await l(3,13,"G2","tauG2"),await l(4,14,"G1","alphaTauG1"),await l(5,15,"G1","betaTauG1"),await i.close(),void await s.close();async function l(e,t,l,c){a&&a.debug("Starting section: "+c),await binFileUtils__namespace.startWriteSection(s,t);for(let a=0;a<=o;a++)await u(a);async function u(t){const u=2**t,f=r[l];r.Fr;const d=2*f.F.n8;let w;f.F.n8,w=new ffjavascript.BigBuffer(u*d),await binFileUtils__namespace.startReadUniqueSection(i,n,e),2==e&&t==o+1?(await i.readToBuffer(w,0,(u-1)*d),w.set(r.G1.zeroAffine,(u-1)*d)):await i.readToBuffer(w,0,u*d),await binFileUtils__namespace.endReadSection(i,!0),w=await f.lagrangeEvaluations(w,"affine","affine",a,c),await s.write(w)}2==e&&await u(o+1),await binFileUtils__namespace.endWriteSection(s)}}async function truncate(e,t,a){const{fd:i,sections:n}=await binFileUtils__namespace.readBinFile(e,"ptau",1),{curve:r,power:o,ceremonyPower:s}=await readPTauHeader(i,n),l=2*r.G1.F.n8,c=2*r.G2.F.n8;for(let f=1;f<o;f++)await u(f);return await i.close(),!0;async function u(e){let o=e.toString();for(;o.length<2;)o="0"+o;a&&a.debug("Writing Power: "+o);const u=await binFileUtils__namespace.createBinFile(t+o+".ptau","ptau",1,11);await writePTauHeader(u,r,e,s),await binFileUtils__namespace.copySection(i,n,u,2,(2**e*2-1)*l),await binFileUtils__namespace.copySection(i,n,u,3,2**e*c),await binFileUtils__namespace.copySection(i,n,u,4,2**e*l),await binFileUtils__namespace.copySection(i,n,u,5,2**e*l),await binFileUtils__namespace.copySection(i,n,u,6,c),await binFileUtils__namespace.copySection(i,n,u,7),await binFileUtils__namespace.copySection(i,n,u,12,(2**(e+1)*2-1)*l),await binFileUtils__namespace.copySection(i,n,u,13,(2**e*2-1)*c),await binFileUtils__namespace.copySection(i,n,u,14,(2**e*2-1)*l),await binFileUtils__namespace.copySection(i,n,u,15,(2**e*2-1)*l),await u.close()}}async function convert(e,t,a){const{fd:i,sections:n}=await binFileUtils__namespace.readBinFile(e,"ptau",1),{curve:r,power:o}=await readPTauHeader(i,n),s=await binFileUtils__namespace.createBinFile(t,"ptau",1,11);return await writePTauHeader(s,r,o),await binFileUtils__namespace.copySection(i,n,s,2),await binFileUtils__namespace.copySection(i,n,s,3),await binFileUtils__namespace.copySection(i,n,s,4),await binFileUtils__namespace.copySection(i,n,s,5),await binFileUtils__namespace.copySection(i,n,s,6),await binFileUtils__namespace.copySection(i,n,s,7),await async function(e,t,l,c){a&&a.debug("Starting section: "+c);await binFileUtils__namespace.startWriteSection(s,t);const u=n[t][0].size,f=i.pageSize;await binFileUtils__namespace.startReadUniqueSection(i,n,t);for(let a=0;a<u;a+=f){const e=Math.min(u-a,f),t=await i.read(e);await s.write(t)}await binFileUtils__namespace.endReadSection(i),2==e&&await async function(t){const u=2**t,f=r[l],d=2*f.F.n8;let w;w=new ffjavascript.BigBuffer(u*d),await binFileUtils__namespace.startReadUniqueSection(i,n,e),2==e&&t==o+1?(await i.readToBuffer(w,0,(u-1)*d),w.set(r.G1.zeroAffine,(u-1)*d)):await i.readToBuffer(w,0,u*d);await binFileUtils__namespace.endReadSection(i,!0),w=await f.lagrangeEvaluations(w,"affine","affine",a,c),await s.write(w)}(o+1);await binFileUtils__namespace.endWriteSection(s)}(2,12,"G1","tauG1"),await binFileUtils__namespace.copySection(i,n,s,13),await binFileUtils__namespace.copySection(i,n,s,14),await binFileUtils__namespace.copySection(i,n,s,15),await i.close(),void await s.close()}async function exportJson(e,t){const{fd:a,sections:i}=await binFileUtils__namespace.readBinFile(e,"ptau",1),{curve:n,power:r}=await readPTauHeader(a,i),o={};return o.q=n.q,o.power=r,o.contributions=await readContributions(a,n,i),o.tauG1=await s(2,"G1",2**r*2-1,"tauG1"),o.tauG2=await s(3,"G2",2**r,"tauG2"),o.alphaTauG1=await s(4,"G1",2**r,"alphaTauG1"),o.betaTauG1=await s(5,"G1",2**r,"betaTauG1"),o.betaG2=await s(6,"G2",1,"betaG2"),o.lTauG1=await l(12,"G1","lTauG1"),o.lTauG2=await l(13,"G2","lTauG2"),o.lAlphaTauG1=await l(14,"G1","lAlphaTauG2"),o.lBetaTauG1=await l(15,"G1","lBetaTauG2"),await a.close(),stringifyBigIntsWithField(n.Fr,o);async function s(e,r,o,s){const l=n[r],c=2*l.F.n8,u=[];await binFileUtils__namespace.startReadUniqueSection(a,i,e);for(let i=0;i<o;i++){t&&i&&i%1e4==0&&console.log(`${s}: `+i);const e=await a.read(c);u.push(l.fromRprLEM(e,0))}return await binFileUtils__namespace.endReadSection(a),u}async function l(e,o,s){const l=n[o],c=2*l.F.n8,u=[];await binFileUtils__namespace.startReadUniqueSection(a,i,e);for(let i=0;i<=r;i++){t&&console.log(`${s}: Power: ${i}`),u[i]=[];const e=2**i;for(let n=0;n<e;n++){t&&n&&n%1e4==0&&console.log(`${s}: ${n}/${e}`);const r=await a.read(c);u[i].push(l.fromRprLEM(r,0))}}return await binFileUtils__namespace.endReadSection(a,!0),u}}var powersoftau=Object.freeze({__proto__:null,newAccumulator:newAccumulator,exportChallenge:exportChallenge,importResponse:importResponse,verify:verify,challengeContribute:challengeContribute,beacon:beacon$1,contribute:contribute,preparePhase2:preparePhase2,truncate:truncate,convert:convert,exportJson:exportJson});function r1csPrint(e,t,a){for(let n=0;n<e.constraints.length;n++)i(e.constraints[n]);function i(i){const n=a=>{let i="";return Object.keys(a).forEach((n=>{let r=t.varIdx2Name[n];"one"==r&&(r="");let o=e.curve.Fr.toString(a[n]);"1"==o&&(o=""),"-1"==o&&(o="-"),""!=i&&"-"!=o[0]&&(o="+"+o),""!=i&&(o=" "+o),i=i+o+r})),i},r=`[ ${n(i[0])} ] * [ ${n(i[1])} ] - [ ${n(i[2])} ] = 0`;a&&a.info(r)}}const bls12381r=ffjavascript.Scalar.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),bn128r=ffjavascript.Scalar.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");async function r1csInfo(e,t){const a=await r1csfile.readR1cs(e);return ffjavascript.Scalar.eq(a.prime,bn128r)?t&&t.info("Curve: bn-128"):ffjavascript.Scalar.eq(a.prime,bls12381r)?t&&t.info("Curve: bls12-381"):t&&t.info(`Unknown Curve. Prime: ${ffjavascript.Scalar.toString(a.prime)}`),t&&t.info(`# of Wires: ${a.nVars}`),t&&t.info(`# of Constraints: ${a.nConstraints}`),t&&t.info(`# of Private Inputs: ${a.nPrvInputs}`),t&&t.info(`# of Public Inputs: ${a.nPubInputs}`),t&&t.info(`# of Labels: ${a.nLabels}`),t&&t.info(`# of Outputs: ${a.nOutputs}`),a}async function r1csExportJson(e,t){const a=await r1csfile.readR1cs(e,!0,!0,!0,t),i=a.curve.Fr;return delete a.curve,delete a.F,stringifyBigIntsWithField(i,a)}var r1cs=Object.freeze({__proto__:null,print:r1csPrint,info:r1csInfo,exportJson:r1csExportJson});async function loadSymbols(e){const t={labelIdx2Name:["one"],varIdx2Name:["one"],componentIdx2Name:[]},a=await fastFile__namespace.readExisting(e),i=await a.read(a.totalSize),n=new TextDecoder("utf-8").decode(i).split("\n");for(let o=0;o<n.length;o++){const e=n[o].split(",");4==e.length&&(t.varIdx2Name[e[1]]?t.varIdx2Name[e[1]]+="|"+e[3]:t.varIdx2Name[e[1]]=e[3],t.labelIdx2Name[e[0]]=e[3],t.componentIdx2Name[e[2]]||(t.componentIdx2Name[e[2]]=r(e[3])))}return await a.close(),t;function r(e){const t=e.split(".");return t.pop(),t.join(".")}}const{unstringifyBigInts:unstringifyBigInts$3}=ffjavascript.utils;async function wtnsDebug(e,t,a,i,n,r){const o=unstringifyBigInts$3(e),s=await fastFile__namespace.readExisting(t),l=await s.read(s.totalSize);await s.close();let c={sanityCheck:!0},u=await loadSymbols(i);n.set&&(u||(u=await loadSymbols(i)),c.logSetSignal=function(e,t){r&&r.info("SET "+u.labelIdx2Name[e]+" <-- "+t.toString())}),n.get&&(u||(u=await loadSymbols(i)),c.logGetSignal=function(e,t){r&&r.info("GET "+u.labelIdx2Name[e]+" --\x3e "+t.toString())}),n.trigger&&(u||(u=await loadSymbols(i)),c.logStartComponent=function(e){r&&r.info("START: "+u.componentIdx2Name[e])},c.logFinishComponent=function(e){r&&r.info("FINISH: "+u.componentIdx2Name[e])}),c.sym=u;const f=await circom_runtime.WitnessCalculatorBuilder(l,c),d=await f.calculateWitness(o),w=await binFileUtils__namespace.createBinFile(a,"wtns",2,2);await write(w,d,f.prime),await w.close()}async function wtnsExportJson(e){return await read(e)}var wtns=Object.freeze({__proto__:null,calculate:wtnsCalculate,debug:wtnsDebug,exportJson:wtnsExportJson});const SUBARRAY_SIZE=262144,BigArrayHandler={get:function(e,t){return isNaN(t)?e[t]:e.getElement(t)},set:function(e,t,a){return isNaN(t)?(e[t]=a,!0):e.setElement(t,a)}};class _BigArray{constructor(e){this.length=e||0,this.arr=new Array(262144);for(let t=0;t<e;t+=262144)this.arr[t/262144]=new Array(Math.min(262144,e-t));return this}push(){for(let e=0;e<arguments.length;e++)this.setElement(this.length,arguments[e])}slice(e,t){const a=new Array(t-e);for(let i=e;i<t;i++)a[i-e]=this.getElement(i);return a}getElement(e){e=parseInt(e);const t=Math.floor(e/262144),a=e%262144;return this.arr[t]?this.arr[t][a]:void 0}setElement(e,t){e=parseInt(e);const a=Math.floor(e/262144);this.arr[a]||(this.arr[a]=new Array(262144));const i=e%262144;return this.arr[a][i]=t,e>=this.length&&(this.length=e+1),!0}getKeys(){const e=new BigArray;for(let t=0;t<this.arr.length;t++)if(this.arr[t])for(let a=0;a<this.arr[t].length;a++)"undefined"!==typeof this.arr[t][a]&&e.push(262144*t+a);return e}}class BigArray{constructor(e){const t=new _BigArray(e);return new Proxy(t,BigArrayHandler)}}async function newZKey(e,t,a,i){const n=0,r=1,o=2,s=3;await Blake2b__default.default.ready();const l=Blake2b__default.default(64),{fd:c,sections:u}=await binFileUtils.readBinFile(t,"ptau",1,1<<22,1<<24),{curve:f,power:d}=await readPTauHeader(c,u),{fd:w,sections:p}=await binFileUtils.readBinFile(e,"r1cs",1,1<<22,1<<24),m=await r1csfile.readR1csHeader(w,p,!1),b=await binFileUtils.createBinFile(a,"zkey",1,10,1<<22,1<<24),g=2*f.G1.F.n8,h=2*f.G2.F.n8;if(m.prime!=f.r)return i&&i.error("r1cs curve does not match powers of tau ceremony curve"),-1;const _=log2(m.nConstraints+m.nPubInputs+m.nOutputs+1-1)+1;if(_>d)return i&&i.error(`circuit too big for this power of tau ceremony. ${m.nConstraints}*2 > 2**${d}`),-1;if(!u[12])return i&&i.error("Powers of tau is not prepared."),-1;const y=m.nOutputs+m.nPubInputs,F=2**_;await binFileUtils.startWriteSection(b,1),await b.writeULE32(1),await binFileUtils.endWriteSection(b),await binFileUtils.startWriteSection(b,2);const v=f.q,G=8*(Math.floor((ffjavascript.Scalar.bitLength(v)-1)/64)+1),U=f.r,S=8*(Math.floor((ffjavascript.Scalar.bitLength(U)-1)/64)+1),B=ffjavascript.Scalar.mod(ffjavascript.Scalar.shl(1,8*S),U),E=f.Fr.e(ffjavascript.Scalar.mod(ffjavascript.Scalar.mul(B,B),U));let x,k,A;await b.writeULE32(G),await binFileUtils.writeBigInt(b,v,G),await b.writeULE32(S),await binFileUtils.writeBigInt(b,U,S),await b.writeULE32(m.nVars),await b.writeULE32(y),await b.writeULE32(F),x=await c.read(g,u[4][0].p),await b.write(x),x=await f.G1.batchLEMtoU(x),l.update(x),k=await c.read(g,u[5][0].p),await b.write(k),k=await f.G1.batchLEMtoU(k),l.update(k),A=await c.read(h,u[6][0].p),await b.write(A),A=await f.G2.batchLEMtoU(A),l.update(A);const C=new Uint8Array(g);f.G1.toRprLEM(C,0,f.G1.g);const L=new Uint8Array(h);f.G2.toRprLEM(L,0,f.G2.g);const R=new Uint8Array(g);f.G1.toRprUncompressed(R,0,f.G1.g);const z=new Uint8Array(h);f.G2.toRprUncompressed(z,0,f.G2.g),await b.write(L),await b.write(C),await b.write(L),l.update(z),l.update(R),l.update(z),await binFileUtils.endWriteSection(b),i&&i.info("Reading r1cs");let T=await binFileUtils.readSection(w,p,2);const I=new BigArray(m.nVars),P=new BigArray(m.nVars),$=new BigArray(m.nVars),j=new BigArray(m.nVars-y-1),H=new Array(y+1);i&&i.info("Reading tauG1");let O=await binFileUtils.readSection(c,u,12,(F-1)*g,F*g);i&&i.info("Reading tauG2");let M=await binFileUtils.readSection(c,u,13,(F-1)*h,F*h);i&&i.info("Reading alphatauG1");let q=await binFileUtils.readSection(c,u,14,(F-1)*g,F*g);i&&i.info("Reading betatauG1");let W=await binFileUtils.readSection(c,u,15,(F-1)*g,F*g);await async function(){const e=new Uint8Array(12+f.Fr.n8),t=new DataView(e.buffer),a=new Uint8Array(f.Fr.n8);f.Fr.toRprLE(a,0,f.Fr.e(1));let l=0;function c(){const e=T.slice(l,l+4);l+=4;return new DataView(e.buffer).getUint32(0,!0)}const u=new BigArray;for(let b=0;b<m.nConstraints;b++){i&&b%1e4==0&&i.debug(`processing constraints: ${b}/${m.nConstraints}`);const e=c();for(let i=0;i<e;i++){const e=c(),t=l;l+=f.Fr.n8;const a=n,i=g*b,r=s,o=g*b;"undefined"===typeof I[e]&&(I[e]=[]),I[e].push([a,i,t]),e<=y?("undefined"===typeof H[e]&&(H[e]=[]),H[e].push([r,o,t])):("undefined"===typeof j[e-y-1]&&(j[e-y-1]=[]),j[e-y-1].push([r,o,t])),u.push([0,b,e,t])}const t=c();for(let i=0;i<t;i++){const e=c(),t=l;l+=f.Fr.n8;const a=n,i=g*b,s=r,d=h*b,w=o,p=g*b;"undefined"===typeof P[e]&&(P[e]=[]),P[e].push([a,i,t]),"undefined"===typeof $[e]&&($[e]=[]),$[e].push([s,d,t]),e<=y?("undefined"===typeof H[e]&&(H[e]=[]),H[e].push([w,p,t])):("undefined"===typeof j[e-y-1]&&(j[e-y-1]=[]),j[e-y-1].push([w,p,t])),u.push([1,b,e,t])}const a=c();for(let i=0;i<a;i++){const e=c(),t=l;l+=f.Fr.n8;const a=n,i=g*b;e<=y?("undefined"===typeof H[e]&&(H[e]=[]),H[e].push([a,i,t])):("undefined"===typeof j[e-y-1]&&(j[e-y-1]=[]),j[e-y-1].push([a,i,t]))}}for(let i=0;i<=y;i++){const e=n,t=g*(m.nConstraints+i),a=s,r=g*(m.nConstraints+i);"undefined"===typeof I[i]&&(I[i]=[]),I[i].push([e,t,-1]),"undefined"===typeof H[i]&&(H[i]=[]),H[i].push([a,r,-1]),u.push([0,m.nConstraints+i,i,-1])}await binFileUtils.startWriteSection(b,4);const d=new ffjavascript.BigBuffer(u.length*(12+f.Fr.n8)+4),w=new Uint8Array(4);new DataView(w.buffer).setUint32(0,u.length,!0),d.set(w);let p=4;for(let n=0;n<u.length;n++)i&&n%1e5==0&&i.debug(`writing coeffs: ${n}/${u.length}`),_(u[n]);function _(i){let n;t.setUint32(0,i[0],!0),t.setUint32(4,i[1],!0),t.setUint32(8,i[2],!0),n=i[3]>=0?f.Fr.fromRprLE(T.slice(i[3],i[3]+f.Fr.n8),0):f.Fr.fromRprLE(a,0);const r=f.Fr.mul(n,E);f.Fr.toRprLE(e,12,r),d.set(e,p),p+=e.length}await b.write(d),await binFileUtils.endWriteSection(b)}(),await V(3,"G1",H,"IC"),await async function(){await binFileUtils.startWriteSection(b,9);const e=new ffjavascript.BigBuffer(F*g);if(_<f.Fr.s){let t=await binFileUtils.readSection(c,u,12,(2*F-1)*g,2*F*g);for(let a=0;a<F;a++){i&&a%1e4==0&&i.debug(`spliting buffer: ${a}/${F}`);const n=t.slice((2*a+1)*g,(2*a+1)*g+g);e.set(n,a*g)}}else{if(_!=f.Fr.s)throw i&&i.error("Circuit too big"),new Error("Circuit too big for this curve");{const t=u[12][0].p+(2**(_+1)-1)*g;await c.readToBuffer(e,0,F*g,t+F*g)}}await b.write(e),await binFileUtils.endWriteSection(b)}(),await async function(){Z(F-1);for(let e=0;e<F-1;e+=16384){i&&i.debug(`HashingHPoints: ${e}/${F}`);const t=Math.min(F-1,16384);await D(e,t)}}(),await V(8,"G1",j,"C"),await V(5,"G1",I,"A"),await V(6,"G1",P,"B1"),await V(7,"G2",$,"B2");const K=l.digest();return await binFileUtils.startWriteSection(b,10),await b.write(K),await b.writeULE32(0),await binFileUtils.endWriteSection(b),i&&i.info(formatHash(K,"Circuit hash: ")),await b.close(),await w.close(),await c.close(),K;async function V(e,t,a,n){const r=f[t];Z(a.length),await binFileUtils.startWriteSection(b,e);let o=[],s=0;for(;s<a.length;){let e=0;for(;s<a.length&&e<f.tm.concurrency;){i&&i.debug(`Writing points start ${n}: ${s}/${a.length}`);let r=1,l=a[s]?a[s].length:0;for(;s+r<a.length&&l+(a[s+r]?a[s+r].length:0)<32768&&r<32768;)l+=a[s+r]?a[s+r].length:0,r++;const c=a.slice(s,s+r),u=s;o.push(N(t,c,i,n).then((e=>(i&&i.debug(`Writing points end ${n}: ${u}/${a.length}`),e)))),s+=r,e++}const c=await Promise.all(o);for(let t=0;t<c.length;t++){await b.write(c[t][0]);const e=await r.batchLEMtoU(c[t][0]);l.update(e)}o=[]}await binFileUtils.endWriteSection(b)}async function N(e,t,a,i){const n=f[e],r=2*n.F.n8,o=3*n.F.n8,s=2*n.F.n8;let l,c,u,d;if("G1"==e)l="g1m_timesScalarAffine",c="g1m_multiexpAffine",u="g1m_batchToAffine",d="g1m_zero";else{if("G2"!=e)throw new Error("Invalid group");l="g2m_timesScalarAffine",c="g2m_multiexpAffine",u="g2m_batchToAffine",d="g2m_zero"}let w,p,m=0;for(let f=0;f<t.length;f++)m+=t[f]?t[f].length:0;m>32768?(w=new ffjavascript.BigBuffer(m*r),p=new ffjavascript.BigBuffer(m*f.Fr.n8)):(w=new Uint8Array(m*r),p=new Uint8Array(m*f.Fr.n8));let b=0,g=0;const h=[O,M,q,W],_=new Uint8Array(f.Fr.n8);f.Fr.toRprLE(_,0,f.Fr.e(1));let y=0;for(let F=0;F<t.length;F++)if(t[F])for(let e=0;e<t[F].length;e++)a&&e&&e%1e4==0&&a.debug(`Configuring big array ${i}: ${e}/${t[F].length}`),w.set(h[t[F][e][0]].slice(t[F][e][1],t[F][e][1]+r),y*r),t[F][e][2]>=0?p.set(T.slice(t[F][e][2],t[F][e][2]+f.Fr.n8),y*f.Fr.n8):p.set(_,y*f.Fr.n8),y++;if(t.length>1){const e=[];e.push({cmd:"ALLOCSET",var:0,buff:w}),e.push({cmd:"ALLOCSET",var:1,buff:p}),e.push({cmd:"ALLOC",var:2,len:t.length*o}),b=0,g=0;let a=0;for(let i=0;i<t.length;i++)t[i]?(1==t[i].length?e.push({cmd:"CALL",fnName:l,params:[{var:0,offset:b},{var:1,offset:g},{val:f.Fr.n8},{var:2,offset:a}]}):e.push({cmd:"CALL",fnName:c,params:[{var:0,offset:b},{var:1,offset:g},{val:f.Fr.n8},{val:t[i].length},{var:2,offset:a}]}),b+=r*t[i].length,g+=f.Fr.n8*t[i].length,a+=o):(e.push({cmd:"CALL",fnName:d,params:[{var:2,offset:a}]}),a+=o);e.push({cmd:"CALL",fnName:u,params:[{var:2},{val:t.length},{var:2}]}),e.push({cmd:"GET",out:0,var:2,len:t.length*s});return await f.tm.queueAction(e)}{let e=await n.multiExpAffine(w,p,a,i);return e=[n.toAffine(e)],e}}async function D(e,t){const a=await c.read(t*g,u[2][0].p+(e+F)*g),i=await c.read(t*g,u[2][0].p+e*g),n=f.tm.concurrency,r=Math.floor(t/n),o=[];for(let l=0;l<n;l++){let e;if(e=l<n-1?r:t-l*r,0==e)continue;const s=a.slice(l*r*g,(l*r+e)*g),c=i.slice(l*r*g,(l*r+e)*g);o.push(Q(s,c))}const s=await Promise.all(o);for(let c=0;c<s.length;c++)l.update(s[c][0])}async function Q(e,t){const a=e.byteLength/g,i=3*f.G1.F.n8,n=[];n.push({cmd:"ALLOCSET",var:0,buff:e}),n.push({cmd:"ALLOCSET",var:1,buff:t}),n.push({cmd:"ALLOC",var:2,len:a*i});for(let r=0;r<a;r++)n.push({cmd:"CALL",fnName:"g1m_subAffine",params:[{var:0,offset:r*g},{var:1,offset:r*g},{var:2,offset:r*i}]});n.push({cmd:"CALL",fnName:"g1m_batchToAffine",params:[{var:2},{val:a},{var:2}]}),n.push({cmd:"CALL",fnName:"g1m_batchLEMtoU",params:[{var:2},{val:a},{var:2}]}),n.push({cmd:"GET",out:0,var:2,len:a*g});return await f.tm.queueAction(n)}function Z(e){const t=new Uint8Array(4);new DataView(t.buffer,t.byteOffset,t.byteLength).setUint32(0,e,!1),l.update(t)}}async function phase2exportMPCParams(e,t,a){const{fd:i,sections:n}=await binFileUtils__namespace.readBinFile(e,"zkey",2),r=await readHeader$1(i,n);if("groth16"!=r.protocol)throw new Error("zkey file is not groth16");const o=await getCurveFromQ(r.q),s=2*o.G1.F.n8,l=2*o.G2.F.n8,c=await readMPCParams(i,o,n),u=await fastFile__namespace.createOverride(t);let f;await h(r.vk_alpha_1),await h(r.vk_beta_1),await _(r.vk_beta_2),await _(r.vk_gamma_2),await h(r.vk_delta_1),await _(r.vk_delta_2),f=await binFileUtils__namespace.readSection(i,n,3),f=await o.G1.batchLEMtoU(f),await y("G1",f);const d=await binFileUtils__namespace.readSection(i,n,9);let w,p,m,b,g;w=await o.G1.fft(d,"affine","jacobian",a),w=await o.G1.batchApplyKey(w,o.Fr.neg(o.Fr.e(2)),o.Fr.w[r.power+1],"jacobian","affine",a),w=w.slice(0,w.byteLength-s),w=await o.G1.batchLEMtoU(w),await y("G1",w),p=await binFileUtils__namespace.readSection(i,n,8),p=await o.G1.batchLEMtoU(p),await y("G1",p),m=await binFileUtils__namespace.readSection(i,n,5),m=await o.G1.batchLEMtoU(m),await y("G1",m),b=await binFileUtils__namespace.readSection(i,n,6),b=await o.G1.batchLEMtoU(b),await y("G1",b),g=await binFileUtils__namespace.readSection(i,n,7),g=await o.G2.batchLEMtoU(g),await y("G2",g),await u.write(c.csHash),await async function(e){const t=new Uint8Array(4);new DataView(t.buffer,t.byteOffset,t.byteLength).setUint32(0,e,!1),await u.write(t)}(c.contributions.length);for(let F=0;F<c.contributions.length;F++){const e=c.contributions[F];await h(e.deltaAfter),await h(e.delta.g1_s),await h(e.delta.g1_sx),await _(e.delta.g2_spx),await u.write(e.transcript)}async function h(e){const t=new Uint8Array(s);o.G1.toRprUncompressed(t,0,e),await u.write(t)}async function _(e){const t=new Uint8Array(l);o.G2.toRprUncompressed(t,0,e),await u.write(t)}async function y(e,t){let a;a="G1"==e?s:l;const i=new Uint8Array(4);new DataView(i.buffer,i.byteOffset,i.byteLength).setUint32(0,t.byteLength/a,!1),await u.write(i),await u.write(t)}await i.close(),await u.close()}async function phase2importMPCParams(e,t,a,i,n){const{fd:r,sections:o}=await binFileUtils__namespace.readBinFile(e,"zkey",2),s=await readHeader$1(r,o,!1);if("groth16"!=s.protocol)throw new Error("zkey file is not groth16");const l=await getCurveFromQ(s.q),c=2*l.G1.F.n8,u=2*l.G2.F.n8,f=await readMPCParams(r,l,o),d={},w=await fastFile__namespace.readExisting(t);w.pos=3*c+3*u+8+c*s.nVars+4+c*(s.domainSize-1)+4+c*s.nVars+4+c*s.nVars+4+u*s.nVars,d.csHash=await w.read(64);const p=await w.readUBE32();d.contributions=[];for(let S=0;S<p;S++){const e={delta:{}};e.deltaAfter=await v(w),e.delta.g1_s=await v(w),e.delta.g1_sx=await v(w),e.delta.g2_spx=await G(w),e.transcript=await w.read(64),S<f.contributions.length&&(e.type=f.contributions[S].type,1==e.type&&(e.beaconHash=f.contributions[S].beaconHash,e.numIterationsExp=f.contributions[S].numIterationsExp),f.contributions[S].name&&(e.name=f.contributions[S].name)),d.contributions.push(e)}if(!hashIsEqual(d.csHash,f.csHash))return n&&n.error("Hash of the original circuit does not match with the MPC one"),!1;if(f.contributions.length>d.contributions.length)return n&&n.error("The impoerted file does not include new contributions"),!1;for(let S=0;S<f.contributions.length;S++)if(!U(f.contributions[S],d.contributions[S]))return n&&n.error(`Previos contribution ${S} does not match`),!1;if(i)for(let S=f.contributions.length;S<d.contributions.length;S++)d.contributions[S].name=i;const m=await binFileUtils__namespace.createBinFile(a,"zkey",1,10);w.pos=0,w.pos+=c,w.pos+=c,w.pos+=u,w.pos+=u,s.vk_delta_1=await v(w),s.vk_delta_2=await G(w),await writeHeader(m,s);if(await w.readUBE32()!=s.nPublic+1)return n&&n.error("Invalid number of points in IC"),await m.discard(),!1;w.pos+=c*(s.nPublic+1),await binFileUtils__namespace.copySection(r,o,m,3),await binFileUtils__namespace.copySection(r,o,m,4);if(await w.readUBE32()!=s.domainSize-1)return n&&n.error("Invalid number of points in H"),await m.discard(),!1;let b;const g=await w.read(c*(s.domainSize-1)),h=await l.G1.batchUtoLEM(g);b=new Uint8Array(s.domainSize*c),b.set(h),l.G1.toRprLEM(b,c*(s.domainSize-1),l.G1.zeroAffine);const _=l.Fr.neg(l.Fr.inv(l.Fr.e(2))),y=l.Fr.inv(l.Fr.w[s.power+1]);b=await l.G1.batchApplyKey(b,_,y,"affine","jacobian",n),b=await l.G1.ifft(b,"jacobian","affine",n),await binFileUtils__namespace.startWriteSection(m,9),await m.write(b),await binFileUtils__namespace.endWriteSection(m);if(await w.readUBE32()!=s.nVars-s.nPublic-1)return n&&n.error("Invalid number of points in L"),await m.discard(),!1;let F;F=await w.read(c*(s.nVars-s.nPublic-1)),F=await l.G1.batchUtoLEM(F),await binFileUtils__namespace.startWriteSection(m,8),await m.write(F),await binFileUtils__namespace.endWriteSection(m);if(await w.readUBE32()!=s.nVars)return n&&n.error("Invalid number of points in A"),await m.discard(),!1;w.pos+=c*s.nVars,await binFileUtils__namespace.copySection(r,o,m,5);if(await w.readUBE32()!=s.nVars)return n&&n.error("Invalid number of points in B1"),await m.discard(),!1;w.pos+=c*s.nVars,await binFileUtils__namespace.copySection(r,o,m,6);return await w.readUBE32()!=s.nVars?(n&&n.error("Invalid number of points in B2"),await m.discard(),!1):(w.pos+=u*s.nVars,await binFileUtils__namespace.copySection(r,o,m,7),await writeMPCParams(m,l,d),await w.close(),await m.close(),await r.close(),!0);async function v(e){const t=await e.read(2*l.G1.F.n8);return l.G1.fromRprUncompressed(t,0)}async function G(e){const t=await e.read(2*l.G2.F.n8);return l.G2.fromRprUncompressed(t,0)}function U(e,t){return!!l.G1.eq(e.deltaAfter,t.deltaAfter)&&(!!l.G1.eq(e.delta.g1_s,t.delta.g1_s)&&(!!l.G1.eq(e.delta.g1_sx,t.delta.g1_sx)&&(!!l.G2.eq(e.delta.g2_spx,t.delta.g2_spx)&&!!hashIsEqual(e.transcript,t.transcript))))}}const sameRatio=sameRatio$2;async function phase2verifyFromInit(e,t,a,i){let n;await Blake2b__default.default.ready();const{fd:r,sections:o}=await binFileUtils__namespace.readBinFile(a,"zkey",2),s=await readHeader$1(r,o,!1);if("groth16"!=s.protocol)throw new Error("zkey file is not groth16");const l=await getCurveFromQ(s.q),c=2*l.G1.F.n8,u=await readMPCParams(r,l,o),f=Blake2b__default.default(64);f.update(u.csHash);let d=l.G1.g;for(let y=0;y<u.contributions.length;y++){const e=u.contributions[y],t=cloneHasher(f);if(hashG1(t,l,e.delta.g1_s),hashG1(t,l,e.delta.g1_sx),!hashIsEqual(t.digest(),e.transcript))return console.log(`INVALID(${y}): Inconsistent transcript `),!1;const a=hashToG2(l,e.transcript);if(n=await sameRatio(l,e.delta.g1_s,e.delta.g1_sx,a,e.delta.g2_spx),!0!==n)return console.log(`INVALID(${y}): public key G1 and G2 do not have the same ration `),!1;if(n=await sameRatio(l,d,e.deltaAfter,a,e.delta.g2_spx),!0!==n)return console.log(`INVALID(${y}): deltaAfter does not fillow the public key `),!1;if(1==e.type){const t=rngFromBeaconParams(e.beaconHash,e.numIterationsExp),a=l.Fr.fromRng(t),i=l.G1.toAffine(l.G1.fromRng(t)),n=l.G1.toAffine(l.G1.timesFr(i,a));if(!0!==l.G1.eq(i,e.delta.g1_s))return console.log(`INVALID(${y}): Key of the beacon does not match. g1_s `),!1;if(!0!==l.G1.eq(n,e.delta.g1_sx))return console.log(`INVALID(${y}): Key of the beacon does not match. g1_sx `),!1}hashPubKey(f,l,e);const i=Blake2b__default.default(64);hashPubKey(i,l,e),e.contributionHash=i.digest(),d=e.deltaAfter}const{fd:w,sections:p}=await binFileUtils__namespace.readBinFile(e,"zkey",2),m=await readHeader$1(w,p,!1);if("groth16"!=m.protocol)throw new Error("zkeyinit file is not groth16");if(!ffjavascript.Scalar.eq(m.q,s.q)||!ffjavascript.Scalar.eq(m.r,s.r)||m.n8q!=s.n8q||m.n8r!=s.n8r)return i&&i.error("INVALID:  Different curves"),!1;if(m.nVars!=s.nVars||m.nPublic!=s.nPublic||m.domainSize!=s.domainSize)return i&&i.error("INVALID:  Different circuit parameters"),!1;if(!l.G1.eq(s.vk_alpha_1,m.vk_alpha_1))return i&&i.error("INVALID:  Invalid alpha1"),!1;if(!l.G1.eq(s.vk_beta_1,m.vk_beta_1))return i&&i.error("INVALID:  Invalid beta1"),!1;if(!l.G2.eq(s.vk_beta_2,m.vk_beta_2))return i&&i.error("INVALID:  Invalid beta2"),!1;if(!l.G2.eq(s.vk_gamma_2,m.vk_gamma_2))return i&&i.error("INVALID:  Invalid gamma2"),!1;if(!l.G1.eq(s.vk_delta_1,d))return i&&i.error("INVALID:  Invalid delta1"),!1;if(n=await sameRatio(l,l.G1.g,d,l.G2.g,s.vk_delta_2),!0!==n)return i&&i.error("INVALID:  Invalid delta2"),!1;const b=await readMPCParams(w,l,p);if(!hashIsEqual(u.csHash,b.csHash))return i&&i.error("INVALID:  Circuit does not match"),!1;if(o[8][0].size!=c*(s.nVars-s.nPublic-1))return i&&i.error("INVALID:  Invalid L section size"),!1;if(o[9][0].size!=c*s.domainSize)return i&&i.error("INVALID:  Invalid H section size"),!1;let g;if(g=await binFileUtils__namespace.sectionIsEqual(r,o,w,p,3),!g)return i&&i.error("INVALID:  IC section is not identical"),!1;if(g=await binFileUtils__namespace.sectionIsEqual(r,o,w,p,4),!g)return i&&i.error("Coeffs section is not identical"),!1;if(g=await binFileUtils__namespace.sectionIsEqual(r,o,w,p,5),!g)return i&&i.error("A section is not identical"),!1;if(g=await binFileUtils__namespace.sectionIsEqual(r,o,w,p,6),!g)return i&&i.error("B1 section is not identical"),!1;if(g=await binFileUtils__namespace.sectionIsEqual(r,o,w,p,7),!g)return i&&i.error("B2 section is not identical"),!1;if(n=await async function(e,t,a,r,o,s,c,u,f){const d=1<<20,w=l[e],p=2*w.F.n8;await binFileUtils__namespace.startReadUniqueSection(t,a,s),await binFileUtils__namespace.startReadUniqueSection(r,o,s);let m=w.zero,b=w.zero;const g=a[s][0].size/p;for(let n=0;n<g;n+=d){i&&i.debug(`Same ratio check ${f}:  ${n}/${g}`);const e=Math.min(g-n,d),a=await t.read(e*p),o=await r.read(e*p),s=new Uint8Array(4*e);crypto__default.default.randomFillSync(s);const l=await w.multiExpAffine(a,s),c=await w.multiExpAffine(o,s);m=w.add(m,l),b=w.add(b,c)}return await binFileUtils__namespace.endReadSection(t),await binFileUtils__namespace.endReadSection(r),0==g||(n=await sameRatio(l,m,b,c,u),!0===n)}("G1",w,p,r,o,8,s.vk_delta_2,m.vk_delta_2,"L section"),!0!==n)return i&&i.error("L section does not match"),!1;if(n=await async function(){const e=1<<20,a=l.G1,c=l.Fr,u=2*a.F.n8,{fd:f,sections:d}=await binFileUtils__namespace.readBinFile(t,"ptau",1);let w=new ffjavascript.BigBuffer(s.domainSize*s.n8r);const p=new Array(8);for(let t=0;t<8;t++)p[t]=crypto__default.default.randomBytes(4).readUInt32BE(0,!0);const b=new ffjavascript.ChaCha(p);for(let t=0;t<s.domainSize-1;t++){const e=c.fromRng(b);c.toRprLE(w,t*s.n8r,e)}c.toRprLE(w,(s.domainSize-1)*s.n8r,c.zero);let g,_=a.zero;for(let t=0;t<s.domainSize;t+=e){i&&i.debug(`H Verificaition(tau):  ${t}/${s.domainSize}`);const n=Math.min(s.domainSize-t,e),r=await f.read(u*n,d[2][0].p+s.domainSize*u+t*u),o=await f.read(u*n,d[2][0].p+t*u),l=await h(r,o),c=w.slice(t*s.n8r,(t+n)*s.n8r),p=await a.multiExpAffine(l,c);_=a.add(_,p)}if(w=await c.batchToMontgomery(w),s.power<c.s)g=c.neg(c.e(2));else{const e=2**c.s,t=c.exp(c.shift,e);g=c.sub(t,c.one)}const y=s.power<c.s?c.w[s.power+1]:c.shift;w=await c.batchApplyKey(w,g,y),w=await c.fft(w),w=await c.batchFromMontgomery(w),await binFileUtils__namespace.startReadUniqueSection(r,o,9);let F=a.zero;for(let t=0;t<s.domainSize;t+=e){i&&i.debug(`H Verificaition(lagrange):  ${t}/${s.domainSize}`);const n=Math.min(s.domainSize-t,e),o=await r.read(u*n),l=w.slice(t*s.n8r,(t+n)*s.n8r),c=await a.multiExpAffine(o,l);F=a.add(F,c)}return await binFileUtils__namespace.endReadSection(r),n=await sameRatio(l,_,F,s.vk_delta_2,m.vk_delta_2),!0===n}(),!0!==n)return i&&i.error("H section does not match"),!1;i&&i.info(formatHash(u.csHash,"Circuit Hash: ")),await r.close(),await w.close();for(let y=u.contributions.length-1;y>=0;y--){const e=u.contributions[y];i&&i.info("-------------------------"),i&&i.info(formatHash(e.contributionHash,`contribution #${y+1} ${e.name?e.name:""}:`)),1==e.type&&(i&&i.info(`Beacon generator: ${byteArray2hex(e.beaconHash)}`),i&&i.info(`Beacon iterations Exp: ${e.numIterationsExp}`))}return i&&i.info("-------------------------"),i&&i.info("ZKey Ok!"),!0;async function h(e,t){const a=2*l.G1.F.n8,i=e.byteLength/a,n=l.tm.concurrency,r=Math.floor(i/n),o=[];for(let l=0;l<n;l++){let a;if(a=l<n-1?r:i-l*r,0==a)continue;const s=e.slice(l*r*c,(l*r+a)*c),u=t.slice(l*r*c,(l*r+a)*c);o.push(_(s,u))}const s=await Promise.all(o),u=new Uint8Array(i*a);let f=0;for(let l=0;l<s.length;l++)u.set(s[l][0],f),f+=s[l][0].byteLength;return u}async function _(e,t){const a=2*l.G1.F.n8,i=3*l.G1.F.n8,n=e.byteLength/a,r=[];r.push({cmd:"ALLOCSET",var:0,buff:e}),r.push({cmd:"ALLOCSET",var:1,buff:t}),r.push({cmd:"ALLOC",var:2,len:n*i});for(let o=0;o<n;o++)r.push({cmd:"CALL",fnName:"g1m_subAffine",params:[{var:0,offset:o*a},{var:1,offset:o*a},{var:2,offset:o*i}]});r.push({cmd:"CALL",fnName:"g1m_batchToAffine",params:[{var:2},{val:n},{var:2}]}),r.push({cmd:"GET",out:0,var:2,len:n*a});return await l.tm.queueAction(r)}}async function phase2verifyFromR1cs(e,t,a,i){const n={type:"bigMem"};return await newZKey(e,t,n,i),await phase2verifyFromInit(n,t,a,i)}async function phase2contribute(e,t,a,i,n){await Blake2b__default.default.ready();const{fd:r,sections:o}=await binFileUtils__namespace.readBinFile(e,"zkey",2),s=await readHeader$1(r,o);if("groth16"!=s.protocol)throw new Error("zkey file is not groth16");const l=await getCurveFromQ(s.q),c=await readMPCParams(r,l,o),u=await binFileUtils__namespace.createBinFile(t,"zkey",1,10),f=await getRandomRng(i),d=Blake2b__default.default(64);d.update(c.csHash);for(let g=0;g<c.contributions.length;g++)hashPubKey(d,l,c.contributions[g]);const w={delta:{}};w.delta.prvKey=l.Fr.fromRng(f),w.delta.g1_s=l.G1.toAffine(l.G1.fromRng(f)),w.delta.g1_sx=l.G1.toAffine(l.G1.timesFr(w.delta.g1_s,w.delta.prvKey)),hashG1(d,l,w.delta.g1_s),hashG1(d,l,w.delta.g1_sx),w.transcript=d.digest(),w.delta.g2_sp=hashToG2(l,w.transcript),w.delta.g2_spx=l.G2.toAffine(l.G2.timesFr(w.delta.g2_sp,w.delta.prvKey)),s.vk_delta_1=l.G1.timesFr(s.vk_delta_1,w.delta.prvKey),s.vk_delta_2=l.G2.timesFr(s.vk_delta_2,w.delta.prvKey),w.deltaAfter=s.vk_delta_1,w.type=0,a&&(w.name=a),c.contributions.push(w),await writeHeader(u,s),await binFileUtils__namespace.copySection(r,o,u,3),await binFileUtils__namespace.copySection(r,o,u,4),await binFileUtils__namespace.copySection(r,o,u,5),await binFileUtils__namespace.copySection(r,o,u,6),await binFileUtils__namespace.copySection(r,o,u,7);const p=l.Fr.inv(w.delta.prvKey);await applyKeyToSection(r,o,u,8,l,"G1",p,l.Fr.e(1),"L Section",n),await applyKeyToSection(r,o,u,9,l,"G1",p,l.Fr.e(1),"H Section",n),await writeMPCParams(u,l,c),await r.close(),await u.close();const m=Blake2b__default.default(64);hashPubKey(m,l,w);const b=m.digest();return n&&n.info(formatHash(c.csHash,"Circuit Hash: ")),n&&n.info(formatHash(b,"Contribution Hash: ")),b}async function beacon(e,t,a,i,n,r){await Blake2b__default.default.ready();const o=hex2ByteArray(i);if(0==o.byteLength||2*o.byteLength!=i.length)return r&&r.error("Invalid Beacon Hash. (It must be a valid hexadecimal sequence)"),!1;if(o.length>=256)return r&&r.error("Maximum lenght of beacon hash is 255 bytes"),!1;if((n=parseInt(n))<10||n>63)return r&&r.error("Invalid numIterationsExp. (Must be between 10 and 63)"),!1;const{fd:s,sections:l}=await binFileUtils__namespace.readBinFile(e,"zkey",2),c=await readHeader$1(s,l);if("groth16"!=c.protocol)throw new Error("zkey file is not groth16");const u=await getCurveFromQ(c.q),f=await readMPCParams(s,u,l),d=await binFileUtils__namespace.createBinFile(t,"zkey",1,10),w=await rngFromBeaconParams(o,n),p=Blake2b__default.default(64);p.update(f.csHash);for(let _=0;_<f.contributions.length;_++)hashPubKey(p,u,f.contributions[_]);const m={delta:{}};m.delta.prvKey=u.Fr.fromRng(w),m.delta.g1_s=u.G1.toAffine(u.G1.fromRng(w)),m.delta.g1_sx=u.G1.toAffine(u.G1.timesFr(m.delta.g1_s,m.delta.prvKey)),hashG1(p,u,m.delta.g1_s),hashG1(p,u,m.delta.g1_sx),m.transcript=p.digest(),m.delta.g2_sp=hashToG2(u,m.transcript),m.delta.g2_spx=u.G2.toAffine(u.G2.timesFr(m.delta.g2_sp,m.delta.prvKey)),c.vk_delta_1=u.G1.timesFr(c.vk_delta_1,m.delta.prvKey),c.vk_delta_2=u.G2.timesFr(c.vk_delta_2,m.delta.prvKey),m.deltaAfter=c.vk_delta_1,m.type=1,m.numIterationsExp=n,m.beaconHash=o,a&&(m.name=a),f.contributions.push(m),await writeHeader(d,c),await binFileUtils__namespace.copySection(s,l,d,3),await binFileUtils__namespace.copySection(s,l,d,4),await binFileUtils__namespace.copySection(s,l,d,5),await binFileUtils__namespace.copySection(s,l,d,6),await binFileUtils__namespace.copySection(s,l,d,7);const b=u.Fr.inv(m.delta.prvKey);await applyKeyToSection(s,l,d,8,u,"G1",b,u.Fr.e(1),"L Section",r),await applyKeyToSection(s,l,d,9,u,"G1",b,u.Fr.e(1),"H Section",r),await writeMPCParams(d,u,f),await s.close(),await d.close();const g=Blake2b__default.default(64);hashPubKey(g,u,m);const h=g.digest();return r&&r.info(formatHash(h,"Contribution Hash: ")),h}async function zkeyExportJson(e){const t=await readZKey(e,!0);return delete t.curve,delete t.F,ffjavascript.utils.stringifyBigInts(t)}async function bellmanContribute(e,t,a,i,n){await Blake2b__default.default.ready();const r=await getRandomRng(i),o=e.Fr.fromRng(r),s=e.Fr.inv(o),l=2*e.G1.F.n8,c=2*e.G2.F.n8,u=await fastFile__namespace.readExisting(t),f=await fastFile__namespace.createOverride(a);await x(l),await x(l),await x(c),await x(c);const d=await k(),w=e.G1.timesFr(d,o);await C(w);const p=await A(),m=e.G2.timesFr(p,o);await L(m);const b=await u.readUBE32();await f.writeUBE32(b),await x(b*l);const g=await u.readUBE32();await f.writeUBE32(g),await applyKeyToChallengeSection(u,f,null,e,"G1",g,s,e.Fr.e(1),"UNCOMPRESSED","H",n);const h=await u.readUBE32();await f.writeUBE32(h),await applyKeyToChallengeSection(u,f,null,e,"G1",h,s,e.Fr.e(1),"UNCOMPRESSED","L",n);const _=await u.readUBE32();await f.writeUBE32(_),await x(_*l);const y=await u.readUBE32();await f.writeUBE32(y),await x(y*l);const F=await u.readUBE32();await f.writeUBE32(F),await x(F*c);const v=Blake2b__default.default(64),G={};G.csHash=await u.read(64),v.update(G.csHash);const U=await u.readUBE32();G.contributions=[];for(let R=0;R<U;R++){const t={delta:{}};t.deltaAfter=await k(),t.delta.g1_s=await k(),t.delta.g1_sx=await k(),t.delta.g2_spx=await A(),t.transcript=await u.read(64),G.contributions.push(t),hashPubKey(v,e,t)}const S={delta:{}};S.delta.prvKey=o,S.delta.g1_s=e.G1.toAffine(e.G1.fromRng(r)),S.delta.g1_sx=e.G1.toAffine(e.G1.timesFr(S.delta.g1_s,o)),hashG1(v,e,S.delta.g1_s),hashG1(v,e,S.delta.g1_sx),S.transcript=v.digest(),S.delta.g2_sp=hashToG2(e,S.transcript),S.delta.g2_spx=e.G2.toAffine(e.G2.timesFr(S.delta.g2_sp,o)),S.deltaAfter=w,S.type=0,G.contributions.push(S),await f.write(G.csHash),await f.writeUBE32(G.contributions.length);for(let R=0;R<G.contributions.length;R++){const e=G.contributions[R];await C(e.deltaAfter),await C(e.delta.g1_s),await C(e.delta.g1_sx),await L(e.delta.g2_spx),await f.write(e.transcript)}const B=Blake2b__default.default(64);hashPubKey(B,e,S);const E=B.digest();return n&&n.info(formatHash(E,"Contribution Hash: ")),await f.close(),await u.close(),E;async function x(e){const t=2*u.pageSize;for(let a=0;a<e;a+=t){const i=Math.min(e-a,t),n=await u.read(i);await f.write(n)}}async function k(){const t=await u.read(2*e.G1.F.n8);return e.G1.fromRprUncompressed(t,0)}async function A(){const t=await u.read(2*e.G2.F.n8);return e.G2.fromRprUncompressed(t,0)}async function C(t){const a=new Uint8Array(l);e.G1.toRprUncompressed(a,0,t),await f.write(a)}async function L(t){const a=new Uint8Array(c);e.G2.toRprUncompressed(a,0,t),await f.write(a)}}const{stringifyBigInts:stringifyBigInts$1}=ffjavascript.utils;async function zkeyExportVerificationKey(e){const{fd:t,sections:a}=await binFileUtils__namespace.readBinFile(e,"zkey",2),i=await readHeader$1(t,a);let n;if("groth16"==i.protocol)n=await groth16Vk(i,t,a);else{if("plonk"!=i.protocol)throw new Error("zkey file is not groth16");n=await plonkVk(i)}return await t.close(),n}async function groth16Vk(e,t,a){const i=await getCurveFromQ(e.q),n=2*i.G1.F.n8,r=await i.pairing(e.vk_alpha_1,e.vk_beta_2);let o={protocol:e.protocol,curve:i.name,nPublic:e.nPublic,vk_alpha_1:i.G1.toObject(e.vk_alpha_1),vk_beta_2:i.G2.toObject(e.vk_beta_2),vk_gamma_2:i.G2.toObject(e.vk_gamma_2),vk_delta_2:i.G2.toObject(e.vk_delta_2),vk_alphabeta_12:i.Gt.toObject(r)};await binFileUtils__namespace.startReadUniqueSection(t,a,3),o.IC=[];for(let s=0;s<=e.nPublic;s++){const e=await t.read(n),a=i.G1.toObject(e);o.IC.push(a)}return await binFileUtils__namespace.endReadSection(t),o=stringifyBigInts$1(o),o}async function plonkVk(e){const t=await getCurveFromQ(e.q);let a={protocol:e.protocol,curve:t.name,nPublic:e.nPublic,power:e.power,k1:t.Fr.toObject(e.k1),k2:t.Fr.toObject(e.k2),Qm:t.G1.toObject(e.Qm),Ql:t.G1.toObject(e.Ql),Qr:t.G1.toObject(e.Qr),Qo:t.G1.toObject(e.Qo),Qc:t.G1.toObject(e.Qc),S1:t.G1.toObject(e.S1),S2:t.G1.toObject(e.S2),S3:t.G1.toObject(e.S3),X_2:t.G2.toObject(e.X_2),w:t.Fr.toObject(t.Fr.w[e.power])};return a=stringifyBigInts$1(a),a}async function exportSolidityVerifier(e,t,a){const i=await zkeyExportVerificationKey(e);let n=t[i.protocol];return ejs__default.default.render(n,i)}var zkey=Object.freeze({__proto__:null,newZKey:newZKey,exportBellman:phase2exportMPCParams,importBellman:phase2importMPCParams,verifyFromR1cs:phase2verifyFromR1cs,verifyFromInit:phase2verifyFromInit,contribute:phase2contribute,beacon:beacon,exportJson:zkeyExportJson,bellmanContribute:bellmanContribute,exportVerificationKey:zkeyExportVerificationKey,exportSolidityVerifier:exportSolidityVerifier});async function plonkSetup(e,t,a,i){globalThis.gc&&globalThis.gc(),await Blake2b__default.default.ready();const{fd:n,sections:r}=await binFileUtils.readBinFile(t,"ptau",1,1<<22,1<<24),{curve:o,power:s}=await readPTauHeader(n,r),{fd:l,sections:c}=await binFileUtils.readBinFile(e,"r1cs",1,1<<22,1<<24),u=await r1csfile.readR1csFd(l,c,{loadConstraints:!0,loadCustomGates:!0}),f=2*o.G1.F.n8,d=o.G1,w=2*o.G2.F.n8,p=o.Fr,m=o.Fr.n8;i&&i.info("Reading r1cs"),await binFileUtils.readSection(l,c,2);const b=new BigArray,g=new BigArray;let h=u.nVars;const _=u.nOutputs+u.nPubInputs;await async function(e,t,a){function i(e){const t=Object.keys(e);for(let a=0;a<t.length;a++)0n==e[t[a]]&&delete e[t[a]]}function n(t,a,n){const r={};for(let i in t)"undefined"==typeof r[i]?r[i]=e.mul(a,t[i]):r[i]=e.add(r[i],e.mul(a,t[i]));for(let i in n)"undefined"==typeof r[i]?r[i]=n[i]:r[i]=e.add(r[i],n[i]);return i(r),r}function r(t,a){const i={k:e.zero,s:[],coefs:[]},n=[];for(let r in t)0==r?i.k=e.add(i.k,t[r]):0n!=t[r]&&n.push([Number(r),t[r]]);for(;n.length>a;){const t=n.shift(),a=n.shift(),i=t[0],r=a[0],o=h++,s=e.zero,l=e.neg(t[1]),c=e.neg(a[1]),u=e.one,f=e.zero;b.push([i,r,o,s,l,c,u,f]),g.push([i,r,t[1],a[1]]),n.push([o,e.one])}for(let e=0;e<n.length;e++)i.s[e]=n[e][0],i.coefs[e]=n[e][1];for(;i.coefs.length<a;)i.s.push(0),i.coefs.push(e.zero);return i}function o(t){const a=r(t,3),i=a.s[0],n=a.s[1],o=a.s[2],s=e.zero,l=a.coefs[0],c=a.coefs[1],u=a.coefs[2],f=a.k;b.push([i,n,o,s,l,c,u,f])}function s(t){let a=e.zero,i=0;const n=Object.keys(t);for(let r=0;r<n.length;r++)0n==t[n[r]]?delete t[n[r]]:0==n[r]?a=e.add(a,t[n[r]]):i++;return i>0?i.toString():a!=e.zero?"k":"0"}function l(t,a,l){const c=s(t),u=s(a);if("0"===c||"0"===u)i(l),o(l);else if("k"===c){o(n(a,t[0],l))}else if("k"===u){o(n(t,a[0],l))}else!function(t,a,i){const n=r(t,1),o=r(a,1),s=r(i,1),l=n.s[0],c=o.s[0],u=s.s[0],f=e.mul(n.coefs[0],o.coefs[0]),d=e.mul(n.coefs[0],o.k),w=e.mul(n.k,o.coefs[0]),p=e.neg(s.coefs[0]),m=e.sub(e.mul(n.k,o.k),s.k);b.push([l,c,u,f,d,w,p,m])}(t,a,l)}for(let c=1;c<=_;c++){const t=c,a=0,i=0,n=e.zero,r=e.one,o=e.zero,s=e.zero,l=e.zero;b.push([t,a,i,n,r,o,s,l])}for(let c=0;c<t.constraints.length;c++)a&&c%1e4===0&&a.debug(`processing constraints: ${c}/${t.nConstraints}`),l(...t.constraints[c])}(o.Fr,u,i),globalThis.gc&&globalThis.gc();const y=await binFileUtils.createBinFile(a,"zkey",1,14,1<<22,1<<24);if(u.prime!=o.r)return i&&i.error("r1cs curve does not match powers of tau ceremony curve"),-1;let F=log2(b.length-1)+1;F<3&&(F=3);const v=2**F;if(i&&i.info("Plonk constraints: "+b.length),F>s)return i&&i.error(`circuit too big for this power of tau ceremony. ${b.length} > 2**${s}`),-1;if(!r[12])return i&&i.error("Powers of tau is not prepared."),-1;const G=new ffjavascript.BigBuffer(v*f),U=r[12][0].p+(2**F-1)*f;await n.readToBuffer(G,0,v*f,U);const[S,B]=function(){let e=p.two;for(;a(e,[],F);)p.add(e,p.one);let t=p.add(e,p.one);for(;a(t,[e],F);)p.add(t,p.one);return[e,t];function a(e,t,a){const i=2**a;let n=p.one;for(let r=0;r<i;r++){if(p.eq(e,n))return!0;for(let a=0;a<t.length;a++)if(p.eq(e,p.mul(t[a],n)))return!0;n=p.mul(n,p.w[a])}return!1}}(),E={};await async function(e,t){await binFileUtils.startWriteSection(y,e);const a=new Uint8Array(8+2*m),n=new DataView(a.buffer);for(let r=0;r<g.length;r++){const e=g[r];let o=0;n.setUint32(o,e[0],!0),o+=4,n.setUint32(o,e[1],!0),o+=4,a.set(e[2],o),o+=m,a.set(e[3],o),o+=m,await y.write(a),i&&r%1e6==0&&i.debug(`writing ${t}: ${r}/${g.length}`)}await binFileUtils.endWriteSection(y)}(3,"Additions"),globalThis.gc&&globalThis.gc(),await k(4,0,"Amap"),globalThis.gc&&globalThis.gc(),await k(5,1,"Bmap"),globalThis.gc&&globalThis.gc(),await k(6,2,"Cmap"),globalThis.gc&&globalThis.gc(),await A(7,3,"Qm"),globalThis.gc&&globalThis.gc(),await A(8,4,"Ql"),globalThis.gc&&globalThis.gc(),await A(9,5,"Qr"),globalThis.gc&&globalThis.gc(),await A(10,6,"Qo"),globalThis.gc&&globalThis.gc(),await A(11,7,"Qc"),globalThis.gc&&globalThis.gc(),await async function(e,t){const a=new ffjavascript.BigBuffer(m*v*3),n=new BigArray(h),r=new BigArray(h);let s=p.one;for(let o=0;o<v;o++)o<b.length?(f(b[o][0],o),f(b[o][1],v+o),f(b[o][2],2*v+o)):(f(0,o),f(0,v+o),f(0,2*v+o)),s=p.mul(s,p.w[F]),i&&o%1e6==0&&i.debug(`writing ${t} phase1: ${o}/${b.length}`);for(let o=0;o<h;o++)"undefined"!==typeof r[o]?a.set(n[o],r[o]*m):console.log("Variable not used"),i&&o%1e6==0&&i.debug(`writing ${t} phase2: ${o}/${h}`);globalThis.gc&&globalThis.gc();await binFileUtils.startWriteSection(y,e);let l=a.slice(0,v*m);await C(l),globalThis.gc&&globalThis.gc();let c=a.slice(v*m,v*m*2);await C(c),globalThis.gc&&globalThis.gc();let u=a.slice(v*m*2,v*m*3);await C(u),globalThis.gc&&globalThis.gc();await binFileUtils.endWriteSection(y),l=await p.batchFromMontgomery(l),c=await p.batchFromMontgomery(c),u=await p.batchFromMontgomery(u),E.S1=await o.G1.multiExpAffine(G,l,i,"multiexp S1"),globalThis.gc&&globalThis.gc();E.S2=await o.G1.multiExpAffine(G,c,i,"multiexp S2"),globalThis.gc&&globalThis.gc();E.S3=await o.G1.multiExpAffine(G,u,i,"multiexp S3"),globalThis.gc&&globalThis.gc();function f(e,t){let i;"undefined"===typeof n[e]?r[e]=t:a.set(n[e],t*m),i=t<v?s:t<2*v?p.mul(s,S):p.mul(s,B),n[e]=i}}(12,"sigma"),globalThis.gc&&globalThis.gc(),await async function(e,t){await binFileUtils.startWriteSection(y,e);const a=Math.max(_,1);for(let n=0;n<a;n++){let e=new ffjavascript.BigBuffer(v*m);e.set(p.one,n*m),await C(e),i&&i.debug(`writing ${t} ${n}/${a}`)}await binFileUtils.endWriteSection(y)}(13,"lagrange polynomials"),globalThis.gc&&globalThis.gc(),await binFileUtils.startWriteSection(y,14);const x=new ffjavascript.BigBuffer((v+6)*f);return await n.readToBuffer(x,0,(v+6)*f,r[2][0].p),await y.write(x),await binFileUtils.endWriteSection(y),globalThis.gc&&globalThis.gc(),await async function(){await binFileUtils.startWriteSection(y,1),await y.writeULE32(2),await binFileUtils.endWriteSection(y),await binFileUtils.startWriteSection(y,2);const e=o.q,t=8*(Math.floor((ffjavascript.Scalar.bitLength(e)-1)/64)+1),a=o.r,i=8*(Math.floor((ffjavascript.Scalar.bitLength(a)-1)/64)+1);let s;await y.writeULE32(t),await binFileUtils.writeBigInt(y,e,t),await y.writeULE32(i),await binFileUtils.writeBigInt(y,a,i),await y.writeULE32(h),await y.writeULE32(_),await y.writeULE32(v),await y.writeULE32(g.length),await y.writeULE32(b.length),await y.write(S),await y.write(B),await y.write(d.toAffine(E.Qm)),await y.write(d.toAffine(E.Ql)),await y.write(d.toAffine(E.Qr)),await y.write(d.toAffine(E.Qo)),await y.write(d.toAffine(E.Qc)),await y.write(d.toAffine(E.S1)),await y.write(d.toAffine(E.S2)),await y.write(d.toAffine(E.S3)),s=await n.read(w,r[3][0].p+w),await y.write(s),await binFileUtils.endWriteSection(y)}(),await y.close(),await l.close(),await n.close(),void(i&&i.info("Setup Finished"));async function k(e,t,a){await binFileUtils.startWriteSection(y,e);for(let n=0;n<b.length;n++)await y.writeULE32(b[n][t]),i&&n%1e6==0&&i.debug(`writing ${a}: ${n}/${b.length}`);await binFileUtils.endWriteSection(y)}async function A(e,t,a){let n=new ffjavascript.BigBuffer(v*m);for(let r=0;r<b.length;r++)n.set(b[r][t],r*m),i&&r%1e6==0&&i.debug(`writing ${a}: ${r}/${b.length}`);await binFileUtils.startWriteSection(y,e),await C(n),await binFileUtils.endWriteSection(y),n=await p.batchFromMontgomery(n),E[a]=await o.G1.multiExpAffine(G,n,i,"multiexp "+a)}async function C(e){const t=await p.ifft(e),a=new ffjavascript.BigBuffer(v*m*4);a.set(t,0);const i=await p.fft(a);await y.write(t),await y.write(i)}}const{stringifyBigInts:stringifyBigInts}=ffjavascript.utils,{keccak256:keccak256$1}=jsSha3__default.default;async function plonk16Prove(e,t,a){const{fd:i,sections:n}=await binFileUtils__namespace.readBinFile(t,"wtns",2,1<<25,1<<23),r=await readHeader(i,n),{fd:o,sections:s}=await binFileUtils__namespace.readBinFile(e,"zkey",2,1<<25,1<<23),l=await readHeader$1(o,s);if("plonk"!=l.protocol)throw new Error("zkey file is not plonk");if(!ffjavascript.Scalar.eq(l.r,r.q))throw new Error("Curve of the witness does not match the curve of the proving key");if(r.nWitness!=l.nVars-l.nAdditions)throw new Error(`Invalid witness length. Circuit: ${l.nVars}, witness: ${r.nWitness}, ${l.nAdditions}`);const c=l.curve,u=c.Fr,f=c.G1,d=c.Fr.n8;a&&a.debug("Reading Wtns");const w=await binFileUtils__namespace.readSection(i,n,2);w.set(u.zero,0);const p=new ffjavascript.BigBuffer(d*l.nAdditions);let m,b,g,h,_,y,F,v,G,U,S,B,E,x;await async function(){const e=await binFileUtils__namespace.readSection(o,s,3),t=8+2*c.Fr.n8;for(let a=0;a<l.nAdditions;a++){const i=P(e,a*t),n=P(e,a*t+4),r=e.slice(a*t+8,a*t+8+d),o=e.slice(a*t+8+d,a*t+8+2*d),s=$(i),l=$(n),u=c.Fr.add(c.Fr.mul(r,s),c.Fr.mul(o,l));p.set(u,d*a)}}();let k={};const A=new ffjavascript.BigBuffer(l.domainSize*d*4*3);let C=s[12][0].p+l.domainSize*d;await o.readToBuffer(A,0,l.domainSize*d*4,C),C+=l.domainSize*d*5,await o.readToBuffer(A,l.domainSize*d*4,l.domainSize*d*4,C),C+=l.domainSize*d*5,await o.readToBuffer(A,l.domainSize*d*8,l.domainSize*d*4,C);const L=new ffjavascript.BigBuffer(l.domainSize*d);await o.readToBuffer(L,0,l.domainSize*d,s[12][0].p);const R=new ffjavascript.BigBuffer(l.domainSize*d);await o.readToBuffer(R,0,l.domainSize*d,s[12][0].p+5*l.domainSize*d);const z=await binFileUtils__namespace.readSection(o,s,14),T={};await async function(){T.b=[];for(let e=1;e<=11;e++)T.b[e]=c.Fr.random();[m,b,g]=await async function(){let e=new ffjavascript.BigBuffer(l.domainSize*d),t=new ffjavascript.BigBuffer(l.domainSize*d),a=new ffjavascript.BigBuffer(l.domainSize*d);const i=await binFileUtils__namespace.readSection(o,s,4),n=await binFileUtils__namespace.readSection(o,s,5),r=await binFileUtils__namespace.readSection(o,s,6);for(let o=0;o<l.nConstrains;o++){const s=P(i,4*o);e.set($(s),o*d);const l=P(n,4*o);t.set($(l),o*d);const c=P(r,4*o);a.set($(c),o*d)}return e=await u.batchToMontgomery(e),t=await u.batchToMontgomery(t),a=await u.batchToMontgomery(a),[e,t,a]}(),[G,_]=await q(m,[T.b[2],T.b[1]]),[U,y]=await q(b,[T.b[4],T.b[3]]),[S,F]=await q(g,[T.b[6],T.b[5]]),k.A=await M(G,"multiexp A"),k.B=await M(U,"multiexp B"),k.C=await M(S,"multiexp C")}(),await async function(){const e=new Uint8Array(l.nPublic*d+2*f.F.n8*3);for(let a=0;a<l.nPublic;a++)u.toRprBE(e,a*d,m.slice(a*d,(a+1)*d));f.toRprUncompressed(e,l.nPublic*d+0,k.A),f.toRprUncompressed(e,l.nPublic*d+2*f.F.n8,k.B),f.toRprUncompressed(e,l.nPublic*d+4*f.F.n8,k.C),T.beta=j(e),a&&a.debug("beta: "+u.toString(T.beta));const t=new Uint8Array(d);u.toRprBE(t,0,T.beta),T.gamma=j(t),a&&a.debug("gamma: "+u.toString(T.gamma));let i=new ffjavascript.BigBuffer(u.n8*l.domainSize),n=new ffjavascript.BigBuffer(u.n8*l.domainSize);i.set(u.one,0),n.set(u.one,0);let r=u.one;for(let a=0;a<l.domainSize;a++){let e=m.slice(a*d,(a+1)*d);e=u.add(e,u.mul(T.beta,r)),e=u.add(e,T.gamma);let t=b.slice(a*d,(a+1)*d);t=u.add(t,u.mul(l.k1,u.mul(T.beta,r))),t=u.add(t,T.gamma);let o=g.slice(a*d,(a+1)*d);o=u.add(o,u.mul(l.k2,u.mul(T.beta,r))),o=u.add(o,T.gamma);const s=u.mul(e,u.mul(t,o));let c=m.slice(a*d,(a+1)*d);c=u.add(c,u.mul(A.slice(a*d*4,a*d*4+d),T.beta)),c=u.add(c,T.gamma);let f=b.slice(a*d,(a+1)*d);f=u.add(f,u.mul(A.slice(4*(l.domainSize+a)*d,4*(l.domainSize+a)*d+d),T.beta)),f=u.add(f,T.gamma);let w=g.slice(a*d,(a+1)*d);w=u.add(w,u.mul(A.slice(4*(2*l.domainSize+a)*d,4*(2*l.domainSize+a)*d+d),T.beta)),w=u.add(w,T.gamma);const p=u.mul(c,u.mul(f,w));i.set(u.mul(i.slice(a*d,(a+1)*d),s),(a+1)%l.domainSize*d),n.set(u.mul(n.slice(a*d,(a+1)*d),p),(a+1)%l.domainSize*d),r=u.mul(r,u.w[l.power])}n=await u.batchInverse(n);for(let a=0;a<l.domainSize;a++)i.set(u.mul(i.slice(a*d,(a+1)*d),n.slice(a*d,(a+1)*d)),a*d);if(!u.eq(i.slice(0,d),u.one))throw new Error("Copy constraints does not match");h=i,[B,v]=await q(h,[T.b[9],T.b[8],T.b[7]]),k.Z=await M(B,"multiexp Z")}(),await async function(){a&&a.debug("phse3: Reading QM4");const e=new ffjavascript.BigBuffer(4*l.domainSize*d);await o.readToBuffer(e,0,l.domainSize*d*4,s[7][0].p+l.domainSize*d),a&&a.debug("phse3: Reading QL4");const t=new ffjavascript.BigBuffer(4*l.domainSize*d);await o.readToBuffer(t,0,l.domainSize*d*4,s[8][0].p+l.domainSize*d),a&&a.debug("phse3: Reading QR4");const i=new ffjavascript.BigBuffer(4*l.domainSize*d);await o.readToBuffer(i,0,l.domainSize*d*4,s[9][0].p+l.domainSize*d),a&&a.debug("phse3: Reading QO4");const n=new ffjavascript.BigBuffer(4*l.domainSize*d);await o.readToBuffer(n,0,l.domainSize*d*4,s[10][0].p+l.domainSize*d),a&&a.debug("phse3: Reading QC4");const r=new ffjavascript.BigBuffer(4*l.domainSize*d);await o.readToBuffer(r,0,l.domainSize*d*4,s[11][0].p+l.domainSize*d);const c=await binFileUtils__namespace.readSection(o,s,13),w=new Uint8Array(2*f.F.n8);f.toRprUncompressed(w,0,k.Z),T.alpha=j(w),a&&a.debug("alpha: "+u.toString(T.alpha));const p=[u.zero,u.add(u.e(-1),u.w[2]),u.e(-2),u.sub(u.e(-1),u.w[2])],b=[u.zero,u.add(u.zero,u.mul(u.e(-2),u.w[2])),u.e(4),u.sub(u.zero,u.mul(u.e(-2),u.w[2]))],g=[u.zero,u.add(u.e(2),u.mul(u.e(2),u.w[2])),u.e(-8),u.sub(u.e(2),u.mul(u.e(2),u.w[2]))],h=new ffjavascript.BigBuffer(4*l.domainSize*d),G=new ffjavascript.BigBuffer(4*l.domainSize*d);let U=u.one;for(let o=0;o<4*l.domainSize;o++){o%4096==0&&a&&a.debug(`calculating t ${o}/${4*l.domainSize}`);const s=_.slice(o*d,o*d+d),f=y.slice(o*d,o*d+d),w=F.slice(o*d,o*d+d),p=v.slice(o*d,o*d+d),b=v.slice((o+4*l.domainSize+4)%(4*l.domainSize)*d,(o+4*l.domainSize+4)%(4*l.domainSize)*d+d),g=e.slice(o*d,o*d+d),S=t.slice(o*d,o*d+d),B=i.slice(o*d,o*d+d),E=n.slice(o*d,o*d+d),x=r.slice(o*d,o*d+d),k=A.slice(o*d,o*d+d),C=A.slice((o+4*l.domainSize)*d,(o+4*l.domainSize)*d+d),L=A.slice((o+8*l.domainSize)*d,(o+8*l.domainSize)*d+d),R=u.add(T.b[2],u.mul(T.b[1],U)),z=u.add(T.b[4],u.mul(T.b[3],U)),$=u.add(T.b[6],u.mul(T.b[5],U)),j=u.square(U),H=u.add(u.add(u.mul(T.b[7],j),u.mul(T.b[8],U)),T.b[9]),O=u.mul(U,u.w[l.power]),M=u.square(O),q=u.add(u.add(u.mul(T.b[7],M),u.mul(T.b[8],O)),T.b[9]);let W=u.zero;for(let e=0;e<l.nPublic;e++)W=u.sub(W,u.mul(c.slice((5*e*l.domainSize+l.domainSize+o)*d,(5*e*l.domainSize+l.domainSize+o+1)*d),m.slice(e*d,(e+1)*d)));let[K,V]=I(s,f,R,z,o%4);K=u.mul(K,g),V=u.mul(V,g),K=u.add(K,u.mul(s,S)),V=u.add(V,u.mul(R,S)),K=u.add(K,u.mul(f,B)),V=u.add(V,u.mul(z,B)),K=u.add(K,u.mul(w,E)),V=u.add(V,u.mul($,E)),K=u.add(K,W),K=u.add(K,x);const N=u.mul(T.beta,U);let D=s;D=u.add(D,N),D=u.add(D,T.gamma);let Q=f;Q=u.add(Q,u.mul(N,l.k1)),Q=u.add(Q,T.gamma);let Z=w;Z=u.add(Z,u.mul(N,l.k2)),Z=u.add(Z,T.gamma);let J=p,[X,Y]=P(D,Q,Z,J,R,z,$,H,o%4);X=u.mul(X,T.alpha),Y=u.mul(Y,T.alpha);let ee=s;ee=u.add(ee,u.mul(T.beta,k)),ee=u.add(ee,T.gamma);let te=f;te=u.add(te,u.mul(T.beta,C)),te=u.add(te,T.gamma);let ae=w;ae=u.add(ae,u.mul(T.beta,L)),ae=u.add(ae,T.gamma);let ie=b,[ne,re]=P(ee,te,ae,ie,R,z,$,q,o%4);ne=u.mul(ne,T.alpha),re=u.mul(re,T.alpha);let oe=u.sub(p,u.one);oe=u.mul(oe,c.slice((l.domainSize+o)*d,(l.domainSize+o+1)*d)),oe=u.mul(oe,u.mul(T.alpha,T.alpha));let se=u.mul(H,c.slice((l.domainSize+o)*d,(l.domainSize+o+1)*d));se=u.mul(se,u.mul(T.alpha,T.alpha));let le=u.add(u.sub(u.add(K,X),ne),oe),ce=u.add(u.sub(u.add(V,Y),re),se);h.set(le,o*d),G.set(ce,o*d),U=u.mul(U,u.w[l.power+2])}a&&a.debug("ifft T");let S=await u.ifft(h);a&&a.debug("dividing T/Z");for(let a=0;a<l.domainSize;a++)S.set(u.neg(S.slice(a*d,a*d+d)),a*d);for(let a=l.domainSize;a<4*l.domainSize;a++){const e=u.sub(S.slice((a-l.domainSize)*d,(a-l.domainSize)*d+d),S.slice(a*d,a*d+d));if(S.set(e,a*d),a>3*l.domainSize-4&&!u.isZero(e))throw new Error("T Polynomial is not divisible")}a&&a.debug("ifft Tz");const B=await u.ifft(G);for(let a=0;a<4*l.domainSize;a++){const e=B.slice(a*d,(a+1)*d);if(a>3*l.domainSize+5){if(!u.isZero(e))throw new Error("Tz Polynomial is not well calculated")}else S.set(u.add(S.slice(a*d,(a+1)*d),e),a*d)}E=S.slice(0,(3*l.domainSize+6)*d);let x=new ffjavascript.BigBuffer((l.domainSize+1)*d);x.set(S.slice(0,l.domainSize*d),0),x.set(T.b[10],l.domainSize*d);let C=new ffjavascript.BigBuffer((l.domainSize+1)*d);C.set(S.slice(l.domainSize*d,2*l.domainSize*d),0);const L=u.sub(C.slice(0,d),T.b[10]);C.set(L,0),C.set(T.b[11],l.domainSize*d);let R=new ffjavascript.BigBuffer((l.domainSize+6)*d);R.set(S.slice(2*l.domainSize*d,(3*l.domainSize+6)*d),0);const z=u.sub(R.slice(0,d),T.b[11]);function I(e,t,a,i,n){let r,o;const s=u.mul(e,t),l=u.mul(e,i),c=u.mul(a,t);r=s;let f=u.mul(a,i);return o=u.add(l,c),n&&(o=u.add(o,u.mul(p[n],f))),[r,o]}function P(e,t,a,i,n,r,o,s,l){let c,f;const d=u.mul(e,t),w=u.mul(e,r),m=u.mul(n,t),h=u.mul(n,r),_=u.mul(a,i),y=u.mul(a,s),F=u.mul(o,i),v=u.mul(o,s);c=u.mul(d,_);let G=u.mul(m,_);G=u.add(G,u.mul(w,_)),G=u.add(G,u.mul(d,F)),G=u.add(G,u.mul(d,y));let U=u.mul(h,_);U=u.add(U,u.mul(m,F)),U=u.add(U,u.mul(m,y)),U=u.add(U,u.mul(w,F)),U=u.add(U,u.mul(w,y)),U=u.add(U,u.mul(d,v));let S=u.mul(w,v);S=u.add(S,u.mul(m,v)),S=u.add(S,u.mul(h,y)),S=u.add(S,u.mul(h,F));let B=u.mul(h,v);return f=G,l&&(f=u.add(f,u.mul(p[l],U)),f=u.add(f,u.mul(b[l],S)),f=u.add(f,u.mul(g[l],B))),[c,f]}R.set(z,0),k.T1=await M(x,"multiexp T1"),k.T2=await M(C,"multiexp T2"),k.T3=await M(R,"multiexp T3")}(),await async function(){const e=new ffjavascript.BigBuffer(l.domainSize*d);await o.readToBuffer(e,0,l.domainSize*d,s[7][0].p);const t=new ffjavascript.BigBuffer(l.domainSize*d);await o.readToBuffer(t,0,l.domainSize*d,s[8][0].p);const i=new ffjavascript.BigBuffer(l.domainSize*d);await o.readToBuffer(i,0,l.domainSize*d,s[9][0].p);const n=new ffjavascript.BigBuffer(l.domainSize*d);await o.readToBuffer(n,0,l.domainSize*d,s[10][0].p);const r=new ffjavascript.BigBuffer(l.domainSize*d);await o.readToBuffer(r,0,l.domainSize*d,s[11][0].p);const c=new ffjavascript.BigBuffer(l.domainSize*d);await o.readToBuffer(c,0,l.domainSize*d,s[12][0].p+10*l.domainSize*d);const w=new Uint8Array(2*f.F.n8*3);f.toRprUncompressed(w,0,k.T1),f.toRprUncompressed(w,2*f.F.n8,k.T2),f.toRprUncompressed(w,4*f.F.n8,k.T3),T.xi=j(w),a&&a.debug("xi: "+u.toString(T.xi));k.eval_a=H(G,T.xi),k.eval_b=H(U,T.xi),k.eval_c=H(S,T.xi),k.eval_s1=H(L,T.xi),k.eval_s2=H(R,T.xi),k.eval_t=H(E,T.xi),k.eval_zw=H(B,u.mul(T.xi,u.w[l.power]));const p=u.mul(k.eval_a,k.eval_b);let m=k.eval_a;const b=u.mul(T.beta,T.xi);m=u.add(m,b),m=u.add(m,T.gamma);let g=k.eval_b;g=u.add(g,u.mul(b,l.k1)),g=u.add(g,T.gamma);let h=k.eval_c;h=u.add(h,u.mul(b,l.k2)),h=u.add(h,T.gamma);const _=u.mul(u.mul(u.mul(m,g),h),T.alpha);let y=k.eval_a;y=u.add(y,u.mul(T.beta,k.eval_s1)),y=u.add(y,T.gamma);let F=k.eval_b;F=u.add(F,u.mul(T.beta,k.eval_s2)),F=u.add(F,T.gamma);let v=u.mul(y,F);v=u.mul(v,T.beta),v=u.mul(v,k.eval_zw),v=u.mul(v,T.alpha),T.xim=T.xi;for(let a=0;a<l.power;a++)T.xim=u.mul(T.xim,T.xim);const A=u.div(u.sub(T.xim,u.one),u.mul(u.sub(T.xi,u.one),u.e(l.domainSize))),C=u.mul(A,u.mul(T.alpha,T.alpha)),z=v,I=u.add(_,C);x=new ffjavascript.BigBuffer((l.domainSize+3)*d);for(let a=0;a<l.domainSize+3;a++){let o=u.mul(I,B.slice(a*d,(a+1)*d));a<l.domainSize&&(o=u.add(o,u.mul(p,e.slice(a*d,(a+1)*d))),o=u.add(o,u.mul(k.eval_a,t.slice(a*d,(a+1)*d))),o=u.add(o,u.mul(k.eval_b,i.slice(a*d,(a+1)*d))),o=u.add(o,u.mul(k.eval_c,n.slice(a*d,(a+1)*d))),o=u.add(o,r.slice(a*d,(a+1)*d)),o=u.sub(o,u.mul(z,c.slice(a*d,(a+1)*d)))),x.set(o,a*d)}k.eval_r=H(x,T.xi)}(),await async function(){const e=new Uint8Array(7*d);u.toRprBE(e,0,k.eval_a),u.toRprBE(e,d,k.eval_b),u.toRprBE(e,2*d,k.eval_c),u.toRprBE(e,3*d,k.eval_s1),u.toRprBE(e,4*d,k.eval_s2),u.toRprBE(e,5*d,k.eval_zw),u.toRprBE(e,6*d,k.eval_r),T.v=[],T.v[1]=j(e),a&&a.debug("v: "+u.toString(T.v[1]));for(let a=2;a<=6;a++)T.v[a]=u.mul(T.v[a-1],T.v[1]);let t=new ffjavascript.BigBuffer((l.domainSize+6)*d);const i=u.mul(T.xim,T.xim);for(let a=0;a<l.domainSize+6;a++){let e=u.zero;const n=E.slice((2*l.domainSize+a)*d,(2*l.domainSize+a+1)*d);if(e=u.add(e,u.mul(i,n)),a<l.domainSize+3&&(e=u.add(e,u.mul(T.v[1],x.slice(a*d,(a+1)*d)))),a<l.domainSize+2&&(e=u.add(e,u.mul(T.v[2],G.slice(a*d,(a+1)*d))),e=u.add(e,u.mul(T.v[3],U.slice(a*d,(a+1)*d))),e=u.add(e,u.mul(T.v[4],S.slice(a*d,(a+1)*d)))),a<l.domainSize){const t=E.slice(a*d,(a+1)*d);e=u.add(e,t);const i=E.slice((l.domainSize+a)*d,(l.domainSize+a+1)*d);e=u.add(e,u.mul(T.xim,i)),e=u.add(e,u.mul(T.v[5],L.slice(a*d,(a+1)*d))),e=u.add(e,u.mul(T.v[6],R.slice(a*d,(a+1)*d)))}0===a&&(e=u.sub(e,u.mul(i,T.b[11])),e=u.sub(e,u.mul(T.xim,T.b[10]))),a===l.domainSize&&(e=u.add(e,T.b[10]),e=u.add(e,u.mul(T.xim,T.b[11]))),t.set(e,a*d)}let n=t.slice(0,d);n=u.sub(n,k.eval_t),n=u.sub(n,u.mul(T.v[1],k.eval_r)),n=u.sub(n,u.mul(T.v[2],k.eval_a)),n=u.sub(n,u.mul(T.v[3],k.eval_b)),n=u.sub(n,u.mul(T.v[4],k.eval_c)),n=u.sub(n,u.mul(T.v[5],k.eval_s1)),n=u.sub(n,u.mul(T.v[6],k.eval_s2)),t.set(n,0),t=O(t,T.xi),k.Wxi=await M(t,"multiexp Wxi");let r=new ffjavascript.BigBuffer((l.domainSize+3)*d);for(let a=0;a<l.domainSize+3;a++){const e=B.slice(a*d,(a+1)*d);r.set(e,a*d)}n=r.slice(0,d),n=u.sub(n,k.eval_zw),r.set(n,0),r=O(r,u.mul(T.xi,u.w[l.power])),k.Wxiw=await M(r,"multiexp Wxiw")}(),k.protocol="plonk",k.curve=c.name,await o.close(),await i.close();let I=[];for(let W=1;W<=l.nPublic;W++){const e=w.slice(W*u.n8,W*u.n8+u.n8);I.push(ffjavascript.Scalar.fromRprLE(e))}return k.A=f.toObject(k.A),k.B=f.toObject(k.B),k.C=f.toObject(k.C),k.Z=f.toObject(k.Z),k.T1=f.toObject(k.T1),k.T2=f.toObject(k.T2),k.T3=f.toObject(k.T3),k.eval_a=u.toObject(k.eval_a),k.eval_b=u.toObject(k.eval_b),k.eval_c=u.toObject(k.eval_c),k.eval_s1=u.toObject(k.eval_s1),k.eval_s2=u.toObject(k.eval_s2),k.eval_zw=u.toObject(k.eval_zw),k.eval_t=u.toObject(k.eval_t),k.eval_r=u.toObject(k.eval_r),k.Wxi=f.toObject(k.Wxi),k.Wxiw=f.toObject(k.Wxiw),delete k.eval_t,k=stringifyBigInts(k),I=stringifyBigInts(I),{proof:k,publicSignals:I};function P(e,t){const a=e.slice(t,t+4);return new DataView(a.buffer,a.byteOffset,a.byteLength).getUint32(0,!0)}function $(e){return e<l.nVars-l.nAdditions?w.slice(e*d,e*d+d):e<l.nVars?p.slice((e-(l.nVars-l.nAdditions))*d,(e-(l.nVars-l.nAdditions))*d+d):c.Fr.zero}function j(e){const t=ffjavascript.Scalar.fromRprBE(new Uint8Array(keccak256$1.arrayBuffer(e)));return u.e(t)}function H(e,t){const a=e.byteLength/d;if(0==a)return u.zero;let i=e.slice((a-1)*d,a*d);for(let n=a-2;n>=0;n--)i=u.add(u.mul(i,t),e.slice(n*d,(n+1)*d));return i}function O(e,t){const a=e.byteLength/d,i=new ffjavascript.BigBuffer(a*d);i.set(u.zero,(a-1)*d),i.set(e.slice((a-1)*d,a*d),(a-2)*d);for(let n=a-3;n>=0;n--)i.set(u.add(e.slice((n+1)*d,(n+2)*d),u.mul(t,i.slice((n+1)*d,(n+2)*d))),n*d);if(!u.eq(e.slice(0,d),u.mul(u.neg(t),i.slice(0,d))))throw new Error("Polinomial does not divide");return i}async function M(e,t){const i=e.byteLength/d,n=z.slice(0,i*c.G1.F.n8*2),r=await c.Fr.batchFromMontgomery(e);let o=await c.G1.multiExpAffine(n,r,a,t);return o=c.G1.toAffine(o),o}async function q(e,t){t=t||[];let a=await u.ifft(e);const i=new ffjavascript.BigBuffer(d*l.domainSize*4);i.set(a,0);const n=new ffjavascript.BigBuffer(d*(l.domainSize+t.length));n.set(a,0);for(let r=0;r<t.length;r++)n.set(u.add(n.slice((l.domainSize+r)*d,(l.domainSize+r+1)*d),t[r]),(l.domainSize+r)*d),n.set(u.sub(n.slice(r*d,(r+1)*d),t[r]),r*d);return[n,await u.fft(i)]}}const{unstringifyBigInts:unstringifyBigInts$2}=ffjavascript.utils;async function plonkFullProve(e,t,a,i){const n=unstringifyBigInts$2(e),r={type:"mem"};return await wtnsCalculate(n,t,r),await plonk16Prove(a,r,i)}const{unstringifyBigInts:unstringifyBigInts$1}=ffjavascript.utils,{keccak256:keccak256}=jsSha3__default.default;async function plonkVerify(e,t,a,i){let n=unstringifyBigInts$1(e),r=unstringifyBigInts$1(a),o=unstringifyBigInts$1(t);const s=await getCurveFromName(n.curve),l=s.Fr,c=s.G1;if(r=fromObjectProof(s,r),n=fromObjectVk(s,n),!isWellConstructed(s,r))return i.error("Proof is not well constructed"),!1;if(o.length!=n.nPublic)return i.error("Invalid number of public inputs"),!1;const u=calculateChallanges(s,r,o);i&&(i.debug("beta: "+l.toString(u.beta,16)),i.debug("gamma: "+l.toString(u.gamma,16)),i.debug("alpha: "+l.toString(u.alpha,16)),i.debug("xi: "+l.toString(u.xi,16)),i.debug("v1: "+l.toString(u.v[1],16)),i.debug("v6: "+l.toString(u.v[6],16)),i.debug("u: "+l.toString(u.u,16)));const f=calculateLagrangeEvaluations(s,u,n);if(i){i.debug("Lagrange Evaluations: ");for(let e=1;e<f.length;e++)i.debug(`L${e}(xi)=`+l.toString(f[e],16))}if(o.length!=n.nPublic)return i.error("Number of public signals does not match with vk"),!1;const d=calculatePl(s,o,f);i&&i.debug("Pl: "+l.toString(d,16));const w=calculateT(s,r,u,d,f[1]);i&&i.debug("t: "+l.toString(w,16));const p=calculateD(s,r,u,n,f[1]);i&&i.debug("D: "+c.toString(c.toAffine(p),16));const m=calculateF(s,r,u,n,p);i&&i.debug("F: "+c.toString(c.toAffine(m),16));const b=calculateE(s,r,u,n,w);i&&i.debug("E: "+c.toString(c.toAffine(b),16));const g=await isValidPairing(s,r,u,n,b,m);return i&&(g?i.info("OK!"):i.warn("Invalid Proof")),g}function fromObjectProof(e,t){const a=e.G1,i=e.Fr,n={};return n.A=a.fromObject(t.A),n.B=a.fromObject(t.B),n.C=a.fromObject(t.C),n.Z=a.fromObject(t.Z),n.T1=a.fromObject(t.T1),n.T2=a.fromObject(t.T2),n.T3=a.fromObject(t.T3),n.eval_a=i.fromObject(t.eval_a),n.eval_b=i.fromObject(t.eval_b),n.eval_c=i.fromObject(t.eval_c),n.eval_zw=i.fromObject(t.eval_zw),n.eval_s1=i.fromObject(t.eval_s1),n.eval_s2=i.fromObject(t.eval_s2),n.eval_r=i.fromObject(t.eval_r),n.Wxi=a.fromObject(t.Wxi),n.Wxiw=a.fromObject(t.Wxiw),n}function fromObjectVk(e,t){const a=e.G1,i=e.G2,n=e.Fr,r=t;return r.Qm=a.fromObject(t.Qm),r.Ql=a.fromObject(t.Ql),r.Qr=a.fromObject(t.Qr),r.Qo=a.fromObject(t.Qo),r.Qc=a.fromObject(t.Qc),r.S1=a.fromObject(t.S1),r.S2=a.fromObject(t.S2),r.S3=a.fromObject(t.S3),r.k1=n.fromObject(t.k1),r.k2=n.fromObject(t.k2),r.X_2=i.fromObject(t.X_2),r}function isWellConstructed(e,t){const a=e.G1;return!!a.isValid(t.A)&&(!!a.isValid(t.B)&&(!!a.isValid(t.C)&&(!!a.isValid(t.Z)&&(!!a.isValid(t.T1)&&(!!a.isValid(t.T2)&&(!!a.isValid(t.T3)&&(!!a.isValid(t.Wxi)&&!!a.isValid(t.Wxiw))))))))}function calculateChallanges(e,t,a){const i=e.G1,n=e.Fr,r=e.Fr.n8,o={},s=new Uint8Array(a.length*r+2*i.F.n8*3);for(let w=0;w<a.length;w++)n.toRprBE(s,w*r,n.e(a[w]));i.toRprUncompressed(s,a.length*r+0,t.A),i.toRprUncompressed(s,a.length*r+2*i.F.n8,t.B),i.toRprUncompressed(s,a.length*r+4*i.F.n8,t.C),o.beta=hashToFr(e,s);const l=new Uint8Array(r);n.toRprBE(l,0,o.beta),o.gamma=hashToFr(e,l);const c=new Uint8Array(2*i.F.n8);i.toRprUncompressed(c,0,t.Z),o.alpha=hashToFr(e,c);const u=new Uint8Array(2*i.F.n8*3);i.toRprUncompressed(u,0,t.T1),i.toRprUncompressed(u,2*i.F.n8,t.T2),i.toRprUncompressed(u,4*i.F.n8,t.T3),o.xi=hashToFr(e,u);const f=new Uint8Array(7*r);n.toRprBE(f,0,t.eval_a),n.toRprBE(f,r,t.eval_b),n.toRprBE(f,2*r,t.eval_c),n.toRprBE(f,3*r,t.eval_s1),n.toRprBE(f,4*r,t.eval_s2),n.toRprBE(f,5*r,t.eval_zw),n.toRprBE(f,6*r,t.eval_r),o.v=[],o.v[1]=hashToFr(e,f);for(let w=2;w<=6;w++)o.v[w]=n.mul(o.v[w-1],o.v[1]);const d=new Uint8Array(2*i.F.n8*2);return i.toRprUncompressed(d,0,t.Wxi),i.toRprUncompressed(d,2*i.F.n8,t.Wxiw),o.u=hashToFr(e,d),o}function calculateLagrangeEvaluations(e,t,a){const i=e.Fr;let n=t.xi,r=1;for(let c=0;c<a.power;c++)n=i.square(n),r*=2;t.xin=n,t.zh=i.sub(n,i.one);const o=[],s=i.e(r);let l=i.one;for(let c=1;c<=Math.max(1,a.nPublic);c++)o[c]=i.div(i.mul(l,t.zh),i.mul(s,i.sub(t.xi,l))),l=i.mul(l,i.w[a.power]);return o}function hashToFr(e,t){const a=ffjavascript.Scalar.fromRprBE(new Uint8Array(keccak256.arrayBuffer(t)));return e.Fr.e(a)}function calculatePl(e,t,a){const i=e.Fr;let n=i.zero;for(let r=0;r<t.length;r++){const e=i.e(t[r]);n=i.sub(n,i.mul(e,a[r+1]))}return n}function calculateT(e,t,a,i,n){const r=e.Fr;let o=t.eval_r;o=r.add(o,i);let s=t.eval_a;s=r.add(s,r.mul(a.beta,t.eval_s1)),s=r.add(s,a.gamma);let l=t.eval_b;l=r.add(l,r.mul(a.beta,t.eval_s2)),l=r.add(l,a.gamma);let c=t.eval_c;c=r.add(c,a.gamma);let u=r.mul(r.mul(s,l),c);u=r.mul(u,t.eval_zw),u=r.mul(u,a.alpha),o=r.sub(o,u),o=r.sub(o,r.mul(n,r.square(a.alpha)));return r.div(o,a.zh)}function calculateD(e,t,a,i,n){const r=e.G1,o=e.Fr;let s=o.mul(o.mul(t.eval_a,t.eval_b),a.v[1]),l=r.timesFr(i.Qm,s),c=o.mul(t.eval_a,a.v[1]);l=r.add(l,r.timesFr(i.Ql,c));let u=o.mul(t.eval_b,a.v[1]);l=r.add(l,r.timesFr(i.Qr,u));let f=o.mul(t.eval_c,a.v[1]);l=r.add(l,r.timesFr(i.Qo,f)),l=r.add(l,r.timesFr(i.Qc,a.v[1]));const d=o.mul(a.beta,a.xi);let w=t.eval_a;w=o.add(w,d),w=o.add(w,a.gamma);let p=t.eval_b;p=o.add(p,o.mul(d,i.k1)),p=o.add(p,a.gamma);let m=t.eval_c;m=o.add(m,o.mul(d,i.k2)),m=o.add(m,a.gamma);let b=o.mul(o.mul(w,p),m);b=o.mul(b,o.mul(a.alpha,a.v[1]));let g=o.mul(o.mul(n,o.square(a.alpha)),a.v[1]);b=o.add(b,g),b=o.add(b,a.u),l=r.add(l,r.timesFr(t.Z,b));let h=t.eval_a;h=o.add(h,o.mul(a.beta,t.eval_s1)),h=o.add(h,a.gamma);let _=t.eval_b;_=o.add(_,o.mul(a.beta,t.eval_s2)),_=o.add(_,a.gamma);let y=o.mul(h,_);return y=o.mul(y,a.alpha),y=o.mul(y,a.v[1]),y=o.mul(y,a.beta),y=o.mul(y,t.eval_zw),l=r.sub(l,r.timesFr(i.S3,y)),l}function calculateF(e,t,a,i,n){const r=e.G1,o=e.Fr;let s=t.T1;return s=r.add(s,r.timesFr(t.T2,a.xin)),s=r.add(s,r.timesFr(t.T3,o.square(a.xin))),s=r.add(s,n),s=r.add(s,r.timesFr(t.A,a.v[2])),s=r.add(s,r.timesFr(t.B,a.v[3])),s=r.add(s,r.timesFr(t.C,a.v[4])),s=r.add(s,r.timesFr(i.S1,a.v[5])),s=r.add(s,r.timesFr(i.S2,a.v[6])),s}function calculateE(e,t,a,i,n){const r=e.G1,o=e.Fr;let s=n;s=o.add(s,o.mul(a.v[1],t.eval_r)),s=o.add(s,o.mul(a.v[2],t.eval_a)),s=o.add(s,o.mul(a.v[3],t.eval_b)),s=o.add(s,o.mul(a.v[4],t.eval_c)),s=o.add(s,o.mul(a.v[5],t.eval_s1)),s=o.add(s,o.mul(a.v[6],t.eval_s2)),s=o.add(s,o.mul(a.u,t.eval_zw));return r.timesFr(r.one,s)}async function isValidPairing(e,t,a,i,n,r){const o=e.G1,s=e.Fr;let l=t.Wxi;l=o.add(l,o.timesFr(t.Wxiw,a.u));let c=o.timesFr(t.Wxi,a.xi);const u=s.mul(s.mul(a.u,a.xi),s.w[i.power]);c=o.add(c,o.timesFr(t.Wxiw,u)),c=o.add(c,r),c=o.sub(c,n);return await e.pairingEq(o.neg(l),i.X_2,c,e.G2.one)}const{unstringifyBigInts:unstringifyBigInts}=ffjavascript.utils;function i2hex(e){return("0"+e.toString(16)).slice(-2)}function p256(e){let t=e.toString(16);for(;t.length<64;)t="0"+t;return t=`"0x${t}"`,t}async function plonkExportSolidityCallData(e,t){const a=unstringifyBigInts(e),i=unstringifyBigInts(t),n=await getCurveFromName(a.curve),r=n.G1,o=n.Fr;let s="";for(let c=0;c<i.length;c++)""!=s&&(s+=","),s+=p256(i[c]);const l=new Uint8Array(2*r.F.n8*9+7*o.n8);r.toRprUncompressed(l,0,r.e(a.A)),r.toRprUncompressed(l,2*r.F.n8,r.e(a.B)),r.toRprUncompressed(l,4*r.F.n8,r.e(a.C)),r.toRprUncompressed(l,6*r.F.n8,r.e(a.Z)),r.toRprUncompressed(l,8*r.F.n8,r.e(a.T1)),r.toRprUncompressed(l,10*r.F.n8,r.e(a.T2)),r.toRprUncompressed(l,12*r.F.n8,r.e(a.T3)),r.toRprUncompressed(l,14*r.F.n8,r.e(a.Wxi)),r.toRprUncompressed(l,16*r.F.n8,r.e(a.Wxiw)),o.toRprBE(l,18*r.F.n8,o.e(a.eval_a)),o.toRprBE(l,18*r.F.n8+o.n8,o.e(a.eval_b)),o.toRprBE(l,18*r.F.n8+2*o.n8,o.e(a.eval_c)),o.toRprBE(l,18*r.F.n8+3*o.n8,o.e(a.eval_s1)),o.toRprBE(l,18*r.F.n8+4*o.n8,o.e(a.eval_s2)),o.toRprBE(l,18*r.F.n8+5*o.n8,o.e(a.eval_zw)),o.toRprBE(l,18*r.F.n8+6*o.n8,o.e(a.eval_r));return"0x"+Array.from(l).map(i2hex).join("")+",["+s+"]"}var plonk=Object.freeze({__proto__:null,setup:plonkSetup,fullProve:plonkFullProve,prove:plonk16Prove,verify:plonkVerify,exportSolidityCallData:plonkExportSolidityCallData});exports.groth16=groth16,exports.plonk=plonk,exports.powersOfTau=powersoftau,exports.r1cs=r1cs,exports.wtns=wtns,exports.zKey=zkey;